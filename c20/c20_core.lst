     1                                           ;代码清单20-2，内核程序
     2                                           ;文件名：c20_core.asm
     3                                           ;李忠，2022-6-7 22:30
     4                                  
     5                                           ;以下常量定义部分。内核的大部分内容都应当固定 
     6                                           flat_core_code_seg_sel  equ  0x0008      ;平坦模型下的内核（0特权级）4GB代码段选择子
     7                                           flat_core_data_seg_sel  equ  0x0010      ;平坦模型下的内核（0特权级）4GB数据段选择子
     8                                           flat_user_code_seg_sel  equ  0x001b      ;平坦模型下的用户（3特权级）4GB代码段选择子
     9                                           flat_user_data_seg_sel  equ  0x0023      ;平坦模型下的用户（3特权级）4GB数据段选择子
    10                                  
    11                                           idt_linear_address    equ  0x8001f000   ;中断描述符表的线性地址
    12                                           core_lin_alloc_at     equ  0x80100000   ;内核中可用于分配的起始线性地址
    13                                           core_lin_tcb_addr     equ  0x8001f800   ;内核任务TCB的高端线性地址
    14                                  
    15                                  ;-------------------------------------------------------------------------------
    16                                           ;以下是系统核心的头部，用于加载核心程序 
    17                                  SECTION header vstart=0x80040000
    18                                  
    19 00000000 [00000000]                       core_length      dd core_end       ;核心程序总长度#00
    20                                  
    21 00000004 [FC000000]                       core_entry       dd start          ;核心代码段入口点#04
    22                                  
    23                                  ;===============================================================================
    24                                           [bits 32]
    25                                  ;===============================================================================
    26                                  SECTION sys_routine vfollows=header          ;系统公共例程代码段
    27                                  ;-------------------------------------------------------------------------------
    28                                           ;字符串显示例程（适用于平坦内存模型）
    29                                  put_string:                                 ;显示0终止的字符串并移动光标
    30                                                                              ;输入：EBX=字符串的线性地址
    31                                  
    32 00000000 53                               push ebx
    33 00000001 51                               push ecx
    34                                  
    35 00000002 9C                               pushfd
    36 00000003 FA                               cli                                ;硬件操作期间，关中断
    37                                  
    38                                    .getc:
    39 00000004 8A0B                             mov cl,[ebx]
    40 00000006 08C9                             or cl,cl                           ;检测串结束标志（0）
    41 00000008 7408                             jz .exit                           ;显示完毕，返回
    42 0000000A E807000000                       call put_char
    43 0000000F 43                               inc ebx
    44 00000010 EBF2                             jmp .getc
    45                                  
    46                                    .exit:
    47                                  
    48 00000012 9D                               popfd                              ;硬件操作完毕，恢复原先中断状态
    49                                  
    50 00000013 59                               pop ecx
    51 00000014 5B                               pop ebx
    52                                  
    53 00000015 C3                               ret
    54                                  
    55                                  ;-------------------------------------------------------------------------------
    56                                  put_char:                                   ;在当前光标处显示一个字符,并推进
    57                                                                              ;光标。仅用于段内调用
    58                                                                              ;输入：CL=字符ASCII码
    59 00000016 60                               pushad
    60                                  
    61                                           ;以下取当前光标位置
    62 00000017 66BAD403                         mov dx,0x3d4
    63 0000001B B00E                             mov al,0x0e
    64 0000001D EE                               out dx,al
    65 0000001E 6642                             inc dx                             ;0x3d5
    66 00000020 EC                               in al,dx                           ;高字
    67 00000021 88C4                             mov ah,al
    68                                  
    69 00000023 664A                             dec dx                             ;0x3d4
    70 00000025 B00F                             mov al,0x0f
    71 00000027 EE                               out dx,al
    72 00000028 6642                             inc dx                             ;0x3d5
    73 0000002A EC                               in al,dx                           ;低字
    74 0000002B 6689C3                           mov bx,ax                          ;BX=代表光标位置的16位数
    75 0000002E 81E3FFFF0000                     and ebx,0x0000ffff                 ;准备使用32位寻址方式访问显存
    76                                  
    77 00000034 80F90D                           cmp cl,0x0d                        ;回车符？
    78 00000037 750E                             jnz .put_0a
    79 00000039 6689D8                           mov ax,bx
    80 0000003C B350                             mov bl,80
    81 0000003E F6F3                             div bl
    82 00000040 F6E3                             mul bl
    83 00000042 6689C3                           mov bx,ax
    84 00000045 EB52                             jmp .set_cursor
    85                                  
    86                                    .put_0a:
    87 00000047 80F90A                           cmp cl,0x0a                        ;换行符？
    88 0000004A 7506                             jnz .put_other
    89 0000004C 6683C350                         add bx,80
    90 00000050 EB0E                             jmp .roll_screen
    91                                  
    92                                    .put_other:                               ;正常显示字符
    93 00000052 66D1E3                           shl bx,1
    94 00000055 888B00800B80                     mov [0x800b8000+ebx],cl
    95                                  
    96                                           ;以下将光标位置推进一个字符
    97 0000005B 66D1EB                           shr bx,1
    98 0000005E 6643                             inc bx
    99                                  
   100                                    .roll_screen:
   101 00000060 6681FBD007                       cmp bx,2000                        ;光标超出屏幕？滚屏
   102 00000065 7C32                             jl .set_cursor
   103                                  
   104 00000067 6653                             push bx                            ;为了修改原书程序的逻辑问题，新增
   105                                  
   106 00000069 FC                               cld
   107 0000006A BEA0800B80                       mov esi,0x800b80a0                 ;小心！32位模式下movsb/w/d
   108 0000006F BF00800B80                       mov edi,0x800b8000                 ;使用的是esi/edi/ecx
   109 00000074 B980070000                       mov ecx,1920
   110 00000079 F3A5                             rep movsd
   111 0000007B 66BB000F                         mov bx,3840                        ;清除屏幕最底一行
   112 0000007F B950000000                       mov ecx,80                         ;32位程序应该使用ECX
   113                                    .cls:
   114 00000084 66C78300800B802007               mov word[0x800b8000+ebx],0x0720
   115 0000008D 6683C302                         add bx,2
   116 00000091 E2F1                             loop .cls
   117                                  
   118                                           ;mov bx,1920                       ;为了修改原书程序的逻辑问题，删除
   119 00000093 665B                             pop bx                             ;为了修改原书程序的逻辑问题，新增
   120 00000095 6683EB50                         sub bx,80                          ;为了修改原书程序的逻辑问题，新增
   121                                  
   122                                    .set_cursor:
   123 00000099 66BAD403                         mov dx,0x3d4
   124 0000009D B00E                             mov al,0x0e
   125 0000009F EE                               out dx,al
   126 000000A0 6642                             inc dx                             ;0x3d5
   127 000000A2 88F8                             mov al,bh
   128 000000A4 EE                               out dx,al
   129 000000A5 664A                             dec dx                             ;0x3d4
   130 000000A7 B00F                             mov al,0x0f
   131 000000A9 EE                               out dx,al
   132 000000AA 6642                             inc dx                             ;0x3d5
   133 000000AC 88D8                             mov al,bl
   134 000000AE EE                               out dx,al
   135                                  
   136 000000AF 61                               popad
   137 000000B0 C3                               ret
   138                                  
   139                                  ;-------------------------------------------------------------------------------
   140                                  read_hard_disk_0:                           ;从硬盘读取一个逻辑扇区（平坦模型）
   141                                                                              ;EAX=逻辑扇区号
   142                                                                              ;EBX=目标缓冲区线性地址
   143                                                                              ;返回：EBX=EBX+512
   144 000000B1 FA                               cli
   145                                  
   146 000000B2 50                               push eax
   147 000000B3 51                               push ecx
   148 000000B4 52                               push edx
   149                                  
   150 000000B5 50                               push eax
   151                                  
   152 000000B6 66BAF201                         mov dx,0x1f2
   153 000000BA B001                             mov al,1
   154 000000BC EE                               out dx,al                          ;读取的扇区数
   155                                  
   156 000000BD 6642                             inc dx                             ;0x1f3
   157 000000BF 58                               pop eax
   158 000000C0 EE                               out dx,al                          ;LBA地址7~0
   159                                  
   160 000000C1 6642                             inc dx                             ;0x1f4
   161 000000C3 B108                             mov cl,8
   162 000000C5 D3E8                             shr eax,cl
   163 000000C7 EE                               out dx,al                          ;LBA地址15~8
   164                                  
   165 000000C8 6642                             inc dx                             ;0x1f5
   166 000000CA D3E8                             shr eax,cl
   167 000000CC EE                               out dx,al                          ;LBA地址23~16
   168                                  
   169 000000CD 6642                             inc dx                             ;0x1f6
   170 000000CF D3E8                             shr eax,cl
   171 000000D1 0CE0                             or al,0xe0                         ;第一硬盘  LBA地址27~24
   172 000000D3 EE                               out dx,al
   173                                  
   174 000000D4 6642                             inc dx                             ;0x1f7
   175 000000D6 B020                             mov al,0x20                        ;读命令
   176 000000D8 EE                               out dx,al
   177                                  
   178                                    .waits:
   179 000000D9 EC                               in al,dx
   180 000000DA 2488                             and al,0x88
   181 000000DC 3C08                             cmp al,0x08
   182 000000DE 75F9                             jnz .waits                         ;不忙，且硬盘已准备好数据传输
   183                                  
   184 000000E0 B900010000                       mov ecx,256                        ;总共要读取的字数
   185 000000E5 66BAF001                         mov dx,0x1f0
   186                                    .readw:
   187 000000E9 66ED                             in ax,dx
   188 000000EB 668903                           mov [ebx],ax
   189 000000EE 83C302                           add ebx,2
   190 000000F1 E2F6                             loop .readw
   191                                  
   192 000000F3 5A                               pop edx
   193 000000F4 59                               pop ecx
   194 000000F5 58                               pop eax
   195                                  
   196 000000F6 FB                               sti
   197                                  
   198 000000F7 C3                               ret
   199                                  
   200                                  ;-------------------------------------------------------------------------------
   201                                  ;汇编语言程序是极难一次成功，而且调试非常困难。这个例程可以提供帮助
   202                                  put_hex_dword:                              ;在当前光标处以十六进制形式显示
   203                                                                              ;一个双字并推进光标
   204                                                                              ;输入：EDX=要转换并显示的数字
   205                                                                              ;输出：无
   206 000000F8 60                               pushad
   207                                  
   208 000000F9 BB[2B010000]                     mov ebx,bin_hex                    ;指向核心地址空间内的转换表
   209 000000FE B908000000                       mov ecx,8
   210                                    .xlt:
   211 00000103 C1C204                           rol edx,4
   212 00000106 89D0                             mov eax,edx
   213 00000108 83E00F                           and eax,0x0000000f
   214 0000010B D7                               xlat
   215                                  
   216 0000010C 51                               push ecx
   217 0000010D 88C1                             mov cl,al
   218 0000010F E802FFFFFF                       call put_char
   219 00000114 59                               pop ecx
   220                                  
   221 00000115 E2EC                             loop .xlt
   222                                  
   223 00000117 61                               popad
   224 00000118 C3                               ret
   225                                  
   226                                  ;-------------------------------------------------------------------------------
   227                                  set_up_gdt_descriptor:                      ;在GDT内安装一个新的描述符
   228                                                                              ;输入：EDX:EAX=描述符
   229                                                                              ;输出：CX=描述符的选择子
   230 00000119 50                               push eax
   231 0000011A 53                               push ebx
   232 0000011B 52                               push edx
   233                                  
   234 0000011C 0F0105[00000000]                 sgdt [pgdt]                        ;取得GDTR的界限和线性地址
   235                                  
   236 00000123 0FB71D[00000000]                 movzx ebx,word [pgdt]              ;GDT界限
   237 0000012A 6643                             inc bx                             ;GDT总字节数，也是下一个描述符偏移
   238 0000012C 031D[02000000]                   add ebx,[pgdt+2]                   ;下一个描述符的线性地址
   239                                  
   240 00000132 8903                             mov [ebx],eax
   241 00000134 895304                           mov [ebx+4],edx
   242                                  
   243 00000137 668305[00000000]08               add word [pgdt],8                  ;增加一个描述符的大小
   244                                  
   245 0000013F 0F0115[00000000]                 lgdt [pgdt]                        ;对GDT的更改生效
   246                                  
   247 00000146 66A1[00000000]                   mov ax,[pgdt]                      ;得到GDT界限值
   248 0000014C 6631D2                           xor dx,dx
   249 0000014F 66BB0800                         mov bx,8
   250 00000153 66F7F3                           div bx                             ;除以8，去掉余数
   251 00000156 6689C1                           mov cx,ax
   252 00000159 66C1E103                         shl cx,3                           ;将索引号移到正确位置
   253                                  
   254 0000015D 5A                               pop edx
   255 0000015E 5B                               pop ebx
   256 0000015F 58                               pop eax
   257                                  
   258 00000160 C3                               ret
   259                                  ;-------------------------------------------------------------------------------
   260                                  make_seg_descriptor:                        ;构造存储器和系统的段描述符
   261                                                                              ;输入：EAX=线性基地址
   262                                                                              ;      EBX=段界限
   263                                                                              ;      ECX=属性。各属性位都在原始
   264                                                                              ;          位置，无关的位清零
   265                                                                              ;返回：EDX:EAX=描述符
   266 00000161 89C2                             mov edx,eax
   267 00000163 C1E010                           shl eax,16
   268 00000166 6609D8                           or ax,bx                           ;描述符前32位(EAX)构造完毕
   269                                  
   270 00000169 81E20000FFFF                     and edx,0xffff0000                 ;清除基地址中无关的位
   271 0000016F C1C208                           rol edx,8
   272 00000172 0FCA                             bswap edx                          ;装配基址的31~24和23~16  (80486+)
   273                                  
   274 00000174 6631DB                           xor bx,bx
   275 00000177 09DA                             or edx,ebx                         ;装配段界限的高4位
   276                                  
   277 00000179 09CA                             or edx,ecx                         ;装配属性
   278                                  
   279 0000017B C3                               ret
   280                                  
   281                                  ;-------------------------------------------------------------------------------
   282                                  make_gate_descriptor:                       ;构造门的描述符（调用门等）
   283                                                                              ;输入：EAX=门代码在段内偏移地址
   284                                                                              ;       BX=门代码所在段的选择子
   285                                                                              ;       CX=段类型及属性等（各属
   286                                                                              ;          性位都在原始位置）
   287                                                                              ;返回：EDX:EAX=完整的描述符
   288 0000017C 53                               push ebx
   289 0000017D 51                               push ecx
   290                                  
   291 0000017E 89C2                             mov edx,eax
   292 00000180 81E20000FFFF                     and edx,0xffff0000                 ;得到偏移地址高16位
   293 00000186 6609CA                           or dx,cx                           ;组装属性部分到EDX
   294                                  
   295 00000189 25FFFF0000                       and eax,0x0000ffff                 ;得到偏移地址低16位
   296 0000018E C1E310                           shl ebx,16
   297 00000191 09D8                             or eax,ebx                         ;组装段选择子部分
   298                                  
   299 00000193 59                               pop ecx
   300 00000194 5B                               pop ebx
   301                                  
   302 00000195 C3                               ret
   303                                  
   304                                  ;-------------------------------------------------------------------------------
   305                                  allocate_a_4k_page:                         ;分配一个4KB的页
   306                                                                              ;输入：无
   307                                                                              ;输出：EAX=页的物理地址
   308 00000196 53                               push ebx
   309 00000197 51                               push ecx
   310 00000198 52                               push edx
   311                                  
   312 00000199 31C0                             xor eax,eax
   313                                    .b1:
   314 0000019B 0FAB05[0C000000]                 bts [page_bit_map],eax
   315 000001A2 7313                             jnc .b2
   316 000001A4 40                               inc eax
   317 000001A5 3D00020000                       cmp eax,page_map_len*8
   318 000001AA 7CEF                             jl .b1
   319                                  
   320 000001AC BB[E9000000]                     mov ebx,message_3
   321 000001B1 E84AFEFFFF                       call put_string
   322 000001B6 F4                               hlt                                ;没有可以分配的页，停机
   323                                  
   324                                    .b2:
   325 000001B7 C1E00C                           shl eax,12                         ;乘以4096（0x1000）
   326                                  
   327 000001BA 5A                               pop edx
   328 000001BB 59                               pop ecx
   329 000001BC 5B                               pop ebx
   330                                  
   331 000001BD C3                               ret
   332                                  
   333                                  ;-------------------------------------------------------------------------------
   334                                  alloc_inst_a_page:                          ;分配一个页，并安装在当前活动的
   335                                                                              ;层级分页结构中
   336                                                                              ;输入：EBX=页的线性地址
   337 000001BE 50                               push eax
   338 000001BF 53                               push ebx
   339 000001C0 51                               push ecx
   340 000001C1 56                               push esi
   341                                  
   342                                           ;检查该线性地址所对应的页表是否存在
   343 000001C2 89DE                             mov esi,ebx
   344 000001C4 81E60000C0FF                     and esi,0xffc00000                 ;清除页表索引和页内偏移部分
   345 000001CA C1EE14                           shr esi,20                         ;将页目录索引乘以4作为页内偏移
   346 000001CD 81CE00F0FFFF                     or esi,0xfffff000                  ;页目录自身的线性地址+表内偏移
   347                                  
   348 000001D3 F70601000000                     test dword [esi],0x00000001        ;P位是否为“1”。检查该线性地址是
   349 000001D9 7529                             jnz .b1                            ;否已经有对应的页表
   350                                  
   351                                           ;创建并安装该线性地址所对应的页表
   352 000001DB E8B6FFFFFF                       call allocate_a_4k_page            ;分配一个页做为页表
   353 000001E0 83C807                           or eax,0x00000007
   354 000001E3 8906                             mov [esi],eax                      ;在页目录中登记该页表
   355                                  
   356                                           ;清空当前页表
   357 000001E5 89D8                             mov eax,ebx
   358 000001E7 250000C0FF                       and eax,0xffc00000
   359 000001EC C1E80A                           shr eax,10
   360 000001EF 0D0000C0FF                       or eax,0xffc00000
   361 000001F4 B900040000                       mov ecx,1024
   362                                    .cls0:
   363 000001F9 C70000000000                     mov dword [eax],0x00000000
   364 000001FF 83C004                           add eax,4
   365 00000202 E2F5                             loop .cls0
   366                                  
   367                                    .b1:
   368                                           ;检查该线性地址对应的页表项（页）是否存在
   369 00000204 89DE                             mov esi,ebx
   370 00000206 81E600F0FFFF                     and esi,0xfffff000                 ;清除页内偏移部分
   371 0000020C C1EE0A                           shr esi,10                         ;将页目录索引变成页表索引，页表索引乘以4作为页内偏移
   372 0000020F 81CE0000C0FF                     or esi,0xffc00000                  ;得到该线性地址对应的页表项
   373                                  
   374 00000215 F70601000000                     test dword [esi],0x00000001        ;P位是否为“1”。检查该线性地址是
   375 0000021B 750A                             jnz .b2                            ;否已经有对应的页
   376                                  
   377                                           ;创建并安装该线性地址所对应的页
   378 0000021D E874FFFFFF                       call allocate_a_4k_page            ;分配一个页，这才是要安装的页
   379 00000222 83C807                           or eax,0x00000007
   380 00000225 8906                             mov [esi],eax
   381                                  
   382                                    .b2:
   383 00000227 5E                               pop esi
   384 00000228 59                               pop ecx
   385 00000229 5B                               pop ebx
   386 0000022A 58                               pop eax
   387                                  
   388 0000022B C3                               ret
   389                                  
   390                                  ;-------------------------------------------------------------------------------
   391                                  create_copy_cur_pdir:                       ;创建新页目录，并复制当前页目录内容
   392                                                                              ;输入：无
   393                                                                              ;输出：EAX=新页目录的物理地址
   394 0000022C 56                               push esi
   395 0000022D 57                               push edi
   396 0000022E 53                               push ebx
   397 0000022F 51                               push ecx
   398                                  
   399 00000230 E861FFFFFF                       call allocate_a_4k_page
   400 00000235 89C3                             mov ebx,eax
   401 00000237 83CB07                           or ebx,0x00000007
   402 0000023A 891DF8FFFFFF                     mov [0xfffffff8],ebx
   403                                  
   404 00000240 0F013DF8FFFFFF                   invlpg [0xfffffff8]
   405                                  
   406 00000247 BE00F0FFFF                       mov esi,0xfffff000                 ;ESI->当前页目录的线性地址
   407 0000024C BF00E0FFFF                       mov edi,0xffffe000                 ;EDI->新页目录的线性地址
   408 00000251 B900040000                       mov ecx,1024                       ;ECX=要复制的目录项数
   409 00000256 FC                               cld
   410 00000257 F3A5                             repe movsd
   411                                  
   412 00000259 59                               pop ecx
   413 0000025A 5B                               pop ebx
   414 0000025B 5F                               pop edi
   415 0000025C 5E                               pop esi
   416                                  
   417 0000025D C3                               ret
   418                                  
   419                                  ;-------------------------------------------------------------------------------
   420                                  task_alloc_memory:                          ;在指定任务的虚拟内存空间中分配内存
   421                                                                              ;输入：EBX=任务控制块TCB的线性地址
   422                                                                              ;      ECX=希望分配的字节数
   423                                                                              ;输出：ECX=已分配的起始线性地址
   424 0000025E 50                               push eax
   425                                  
   426 0000025F 53                               push ebx                           ;to A
   427                                  
   428                                           ;获得本次内存分配的起始线性地址
   429 00000260 8B5B06                           mov ebx,[ebx+0x06]                 ;获得本次分配的起始线性地址
   430 00000263 89D8                             mov eax,ebx
   431 00000265 01D9                             add ecx,ebx                        ;本次分配，最后一个字节之后的线性地址
   432                                  
   433 00000267 51                               push ecx                           ;To B
   434                                  
   435                                           ;为请求的内存分配页
   436 00000268 81E300F0FFFF                     and ebx,0xfffff000
   437 0000026E 81E100F0FFFF                     and ecx,0xfffff000
   438                                    .next:
   439 00000274 E845FFFFFF                       call alloc_inst_a_page
   440                                                                              ;安装当前线性地址所在的页
   441 00000279 81C300100000                     add ebx,0x1000                     ;+4096
   442 0000027F 39CB                             cmp ebx,ecx
   443 00000281 7EF1                             jle .next
   444                                  
   445                                           ;将用于下一次分配的线性地址强制按4字节对齐
   446 00000283 59                               pop ecx                            ;B
   447                                  
   448 00000284 F7C103000000                     test ecx,0x00000003                ;线性地址是4字节对齐的吗？
   449 0000028A 7406                             jz .algn                           ;是，直接返回
   450 0000028C 83C104                           add ecx,4                          ;否，强制按4字节对齐
   451 0000028F 83E1FC                           and ecx,0xfffffffc
   452                                  
   453                                    .algn:
   454 00000292 5B                               pop ebx                            ;A
   455                                  
   456 00000293 894B06                           mov [ebx+0x06],ecx                 ;将下次分配可用的线性地址回存到TCB中
   457 00000296 89C1                             mov ecx,eax
   458                                  
   459 00000298 58                               pop eax
   460                                  
   461 00000299 C3                               ret
   462                                  
   463                                  ;-------------------------------------------------------------------------------
   464                                  allocate_memory:                            ;在当前任务的地址空间中分配内存
   465                                                                              ;输入：ECX=希望分配的字节数
   466                                                                              ;输出：ECX=所分配内存的起始线性地址
   467 0000029A 50                               push eax
   468 0000029B 53                               push ebx
   469                                  
   470                                           ;得到TCB链表首节点的线性地址
   471 0000029C A1[3B090000]                     mov eax,[tcb_chain]                ;EAX=首节点的线性地址
   472                                  
   473                                           ;搜索状态为忙（当前任务）的节点
   474                                    .s0:
   475 000002A1 66837804FF                       cmp word [eax+0x04],0xffff
   476 000002A6 7404                             jz .s1                             ;找到忙的节点，EAX=节点的线性地址
   477 000002A8 8B00                             mov eax,[eax]
   478 000002AA EBF5                             jmp .s0
   479                                  
   480                                           ;开始分配内存
   481                                    .s1:
   482 000002AC 89C3                             mov ebx,eax
   483 000002AE E8ABFFFFFF                       call task_alloc_memory
   484                                  
   485 000002B3 5B                               pop ebx
   486 000002B4 58                               pop eax
   487                                  
   488 000002B5 C3                               ret
   489                                  
   490                                  ;-------------------------------------------------------------------------------
   491                                  resume_task_execute:                        ;恢复指定任务的执行
   492                                                                              ;输入：EDI=新任务的TCB的线性地址
   493 000002B6 8B470A                           mov eax, [edi + 10]
   494 000002B9 A3[43090000]                     mov [tss + 4], eax                 ;用新任务的RSP0设置TSS的RSP0域
   495                                  
   496 000002BE 8B4716                           mov eax, [edi + 22]
   497 000002C1 0F22D8                           mov cr3, eax                       ;恢复新任务的CR3
   498                                  
   499 000002C4 8E5F22                           mov ds, [edi + 34]
   500 000002C7 8E4724                           mov es, [edi + 36]
   501 000002CA 8E6726                           mov fs, [edi + 38]
   502 000002CD 8E6F28                           mov gs, [edi + 40]
   503 000002D0 8B472A                           mov eax, [edi + 42]
   504 000002D3 8B5F2E                           mov ebx, [edi + 46]
   505 000002D6 8B4F32                           mov ecx, [edi + 50]
   506 000002D9 8B5736                           mov edx, [edi + 54]
   507 000002DC 8B773A                           mov esi, [edi + 58]
   508 000002DF 8B6F42                           mov ebp, [edi + 66]
   509                                  
   510 000002E2 66F747200300                     test word [edi + 32], 3           ;SS.RPL=3？
   511 000002E8 7508                             jnz .to_r3                        ;是的。转.to_r3
   512 000002EA 8B6746                           mov esp, [edi + 70]
   513 000002ED 8E5720                           mov ss, [edi + 32]
   514 000002F0 EB06                             jmp .do_sw
   515                                  
   516                                    .to_r3:
   517 000002F2 FF7720                           push dword [edi + 32]             ;SS
   518 000002F5 FF7746                           push dword [edi + 70]             ;ESP
   519                                    .do_sw:
   520 000002F8 FF774A                           push dword [edi + 74]             ;EFLAGS
   521 000002FB FF771E                           push dword [edi + 30]             ;CS
   522 000002FE FF771A                           push dword [edi + 26]             ;EIP
   523                                  
   524 00000301 66F75704                         not word [edi + 0x04]             ;将就绪状态的节点改为忙状态的节点
   525 00000305 8B7F3E                           mov edi, [edi + 62]
   526                                  
   527 00000308 CF                               iretd
   528                                  
   529                                  ;-------------------------------------------------------------------------------
   530                                  initiate_task_switch:                       ;主动发起任务切换
   531                                                                              ;输入：无
   532                                                                              ;输出：无。
   533 00000309 50                               push eax
   534 0000030A 53                               push ebx
   535 0000030B 56                               push esi
   536 0000030C 57                               push edi
   537                                  
   538 0000030D A1[3B090000]                     mov eax, [tcb_chain]
   539 00000312 83F800                           cmp eax, 0                         ;链表为空？
   540 00000315 7472                             jz .return
   541                                  
   542                                           ;搜索状态为忙（当前任务）的节点
   543                                    .b0:
   544 00000317 66837804FF                       cmp word [eax + 4], 0xffff
   545 0000031C 0F44F0                           cmove esi, eax                     ;若找到忙的节点，ESI=节点的线性地址
   546 0000031F 7404                             jz .b1
   547 00000321 8B00                             mov eax, [eax]
   548 00000323 EBF2                             jmp .b0                            ;循环总能终止，起码内核任务是存在的并且为忙
   549                                  
   550                                           ;从当前节点继续搜索就绪任务的节点
   551                                    .b1:
   552 00000325 8B18                             mov ebx, [eax]
   553 00000327 09DB                             or ebx, ebx                        ;到达链表尾部？
   554 00000329 740E                             jz .b2                             ;到链表尾部也未发现就绪节点，从头找
   555 0000032B 66837B0400                       cmp word [ebx + 4], 0              ;是就绪状态？
   556 00000330 0F44FB                           cmove edi, ebx                     ;若找到就绪节点，EDI=节点的线性地址
   557 00000333 741C                             jz .b3
   558 00000335 89D8                             mov eax, ebx
   559 00000337 EBEC                             jmp .b1
   560                                  
   561                                    .b2:   ;从链表头寻找就绪任务的节点
   562 00000339 8B1D[3B090000]                   mov ebx, [tcb_chain]               ;EBX=链表首节点线性地址
   563                                    .b20:
   564 0000033F 66837B0400                       cmp word [ebx + 4], 0
   565 00000344 0F44FB                           cmove edi, ebx                     ;已找到就绪节点，EDI=节点的线性地址
   566 00000347 7408                             jz .b3
   567 00000349 8B1B                             mov ebx, [ebx]
   568 0000034B 09DB                             or ebx, ebx
   569 0000034D 743A                             jz .return                         ;链表中已经不存在就绪任务，返回
   570 0000034F EBEE                             jmp .b20
   571                                  
   572                                    .b3:
   573                                           ;保存旧任务的状态
   574 00000351 0F20D8                           mov eax, cr3
   575 00000354 894616                           mov [esi + 22], eax                ;保存CR3
   576                                           ;EAX/EBX/ESI/EDI不用保存，在任务恢复执行时将自动从栈中弹出并恢复
   577 00000357 894E32                           mov [esi + 50], ecx
   578 0000035A 895636                           mov [esi + 54], edx
   579 0000035D 896E42                           mov [esi + 66], ebp
   580 00000360 896646                           mov [esi + 70], esp
   581 00000363 C7461A[89030000]                 mov dword [esi + 26], .return      ;恢复执行时的EIP
   582 0000036A 8C4E1E                           mov [esi + 30], cs
   583 0000036D 8C5620                           mov [esi + 32], ss
   584 00000370 8C5E22                           mov [esi + 34], ds
   585 00000373 8C4624                           mov [esi + 36], es
   586 00000376 8C6626                           mov [esi + 38], fs
   587 00000379 8C6E28                           mov [esi + 40], gs
   588 0000037C 9C                               pushfd
   589 0000037D 8F464A                           pop dword [esi + 74]
   590 00000380 66F75604                         not word [esi + 4]                 ;将忙状态的节点改为就绪状态的节点
   591                                  
   592 00000384 E92DFFFFFF                       jmp resume_task_execute            ;转去恢复并执行新任务
   593                                  
   594                                    .return:
   595 00000389 5F                               pop edi
   596 0000038A 5E                               pop esi
   597 0000038B 5B                               pop ebx
   598 0000038C 58                               pop eax
   599                                  
   600 0000038D C3                               ret
   601                                  
   602                                  ;-------------------------------------------------------------------------------
   603                                  terminate_current_task:                     ;终止当前任务
   604                                                                              ;注意，执行此例程时，当前任务仍在
   605                                                                              ;运行中。此例程其实也是当前任务的
   606                                                                              ;一部分 
   607 0000038E 8B3D[3B090000]                   mov edi, [tcb_chain]
   608                                                                              ;EAX=首节点的线性地址
   609                                           ;搜索状态为忙（当前任务）的节点
   610                                    .s0:
   611 00000394 66837F04FF                       cmp word [edi + 4], 0xffff
   612 00000399 7404                             jz .s1                             ;找到忙的节点，EAX=节点的线性地址
   613 0000039B 8B3F                             mov edi, [edi]
   614 0000039D EBF5                             jmp .s0
   615                                  
   616                                           ;将状态为忙的节点改成终止状态
   617                                    .s1:
   618 0000039F 66C747043333                     mov word [edi + 4], 0x3333
   619                                  
   620                                           ;搜索就绪状态的任务
   621 000003A5 8B3D[3B090000]                   mov edi, [tcb_chain]               ;EBX=链表首节点线性地址
   622                                    .s2:
   623 000003AB 66837F0400                       cmp word [edi + 4], 0x0000
   624 000003B0 7404                             jz .s3                             ;已找到就绪节点，EBX=节点的线性地址
   625 000003B2 8B3F                             mov edi, [edi]
   626 000003B4 EBF5                             jmp .s2
   627                                  
   628                                           ;就绪任务的节点已经找到，准备切换到该任务
   629                                    .s3:
   630 000003B6 E9FBFEFFFF                       jmp resume_task_execute            ;转去恢复并执行新任务
   631                                  
   632                                  ;-------------------------------------------------------------------------------
   633                                  general_interrupt_handler:                  ;通用的中断处理过程
   634 000003BB 50                               push eax
   635                                  
   636 000003BC B020                             mov al,0x20                        ;中断结束命令EOI
   637 000003BE E6A0                             out 0xa0,al                        ;向从片发送
   638 000003C0 E620                             out 0x20,al                        ;向主片发送
   639                                  
   640 000003C2 58                               pop eax
   641 000003C3 CF                               iretd
   642                                  
   643                                  ;-------------------------------------------------------------------------------
   644                                  general_exception_handler:                  ;通用的异常处理过程
   645 000003C4 BB[07010000]                     mov ebx,excep_msg
   646 000003C9 E832FCFFFF                       call put_string
   647                                  
   648 000003CE FA                               cli
   649                                  
   650 000003CF F4                               hlt
   651                                  
   652                                  ;-------------------------------------------------------------------------------
   653                                  rtm_0x70_interrupt_handle:                  ;实时时钟中断处理过程
   654 000003D0 50                               push eax
   655                                  
   656 000003D1 B020                             mov al, 0x20                       ;中断结束命令EOI
   657 000003D3 E6A0                             out 0xa0, al                       ;向8259A从片发送
   658 000003D5 E620                             out 0x20, al                       ;向8259A主片发送
   659                                  
   660 000003D7 B00C                             mov al, 0x0c                       ;寄存器C的索引。且开放NMI
   661 000003D9 E670                             out 0x70, al
   662 000003DB E471                             in al, 0x71                        ;读一下RTC的寄存器C，否则只发生一次中断
   663                                                                              ;此处不考虑闹钟和周期性中断的情况
   664 000003DD E827FFFFFF                       call initiate_task_switch          ;发起任务切换
   665                                  
   666 000003E2 58                               pop eax
   667                                  
   668 000003E3 CF                               iretd
   669                                  
   670                                  ;-------------------------------------------------------------------------------
   671                                  do_task_clean:                             ;清理已经终止的任务并回收资源
   672                                  
   673                                           ;搜索TCB链表，找到状态为终止的节点
   674                                           ;将节点从链表中拆除
   675                                           ;回收任务占用的各种资源（可以从它的TCB中找到）
   676                                  
   677 000003E4 C3                               ret
   678                                  
   679                                  ;-------------------------------------------------------------------------------
   680                                  int_0x88_handler:                          ;系统调用处理过程
   681                                  
   682 000003E5 FF1485[4C000000]                 call [eax * 4 + sys_call]
   683 000003EC CF                               iretd
   684                                  
   685                                  ;===============================================================================
   686                                  SECTION core_data vfollows=sys_routine       ;系统核心的数据段
   687                                  ;------------------------------------------------------------------------------- 
   688 00000000 0000                             pgdt             dw  0             ;用于设置和修改GDT 
   689 00000002 00000000                                          dd  0
   690                                  
   691 00000006 0000                             pidt             dw  0
   692 00000008 00000000                                          dd  0
   693                                  
   694 0000000C FFFFFFFFFFFF5555                 page_bit_map     db  0xff,0xff,0xff,0xff,0xff,0xff,0x55,0x55
   695 00000014 FFFFFFFFFFFFFFFF                                  db  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
   696 0000001C FFFFFFFFFFFFFFFF                                  db  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
   697 00000024 FFFFFFFFFFFFFFFF                                  db  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
   698 0000002C 5555555555555555                                  db  0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55
   699 00000034 0000000000000000                                  db  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   700 0000003C 0000000000000000                                  db  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   701 00000044 0000000000000000                                  db  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   702                                           page_map_len     equ $-page_bit_map
   703                                  
   704                                           ;系统调用功能入口
   705 0000004C [00000000]                       sys_call         dd put_string
   706 00000050 [B1000000]                                        dd read_hard_disk_0
   707 00000054 [F8000000]                                        dd put_hex_dword
   708 00000058 [8E030000]                                        dd terminate_current_task
   709 0000005C [09030000]                                        dd initiate_task_switch
   710 00000060 [9A020000]                                        dd allocate_memory
   711                                  
   712 00000064 536574757020696E74-              message_0        db 'Setup interrupt system and system-call......', 0
   712 0000006D 657272757074207379-
   712 00000076 7374656D20616E6420-
   712 0000007F 73797374656D2D6361-
   712 00000088 6C6C2E2E2E2E2E2E00 
   713                                  
   714 00000091 446F6E652E0D0A00                 message_1        db  'Done.', 0x0d, 0x0a, 0
   715                                  
   716 00000099 545353206973206372-              message_2        db  'TSS is created.', 0x0d, 0x0a, 0
   716 000000A2 65617465642E0D0A00 
   717                                  
   718 000000AB 0D0A202000                       cpu_brnd0        db  0x0d,0x0a,'  ',0
   719 000000B0 00<rep 34h>                      cpu_brand  times 52  db 0
   720 000000E4 0D0A0D0A00                       cpu_brnd1        db  0x0d,0x0a,0x0d,0x0a,0
   721                                  
   722 000000E9 2A2A2A2A2A2A2A2A4E-              message_3        db  '********No more pages********',0
   722 000000F2 6F206D6F7265207061-
   722 000000FB 6765732A2A2A2A2A2A-
   722 00000104 2A2A00             
   723                                  
   724 00000107 2A2A2A2A2A2A2A2A45-              excep_msg        db  '********Exception encounted********',0
   724 00000110 7863657074696F6E20-
   724 00000119 656E636F756E746564-
   724 00000122 2A2A2A2A2A2A2A2A00 
   725                                  
   726 0000012B 303132333435363738-              bin_hex          db '0123456789ABCDEF'
   726 00000134 39414243444546     
   727                                                                              ;put_hex_dword子过程用的查找表 
   728                                  
   729 0000013B 00<rep 800h>                     core_buf   times 2048 db 0         ;内核用的缓冲区
   730                                  
   731 0000093B 00000000                         tcb_chain        dd  0             ;任务控制块链
   732                                  
   733 0000093F 00<rep 80h>                      tss              times 128 db  0   ;任务状态段
   734                                  
   735 000009BF 436F7265207461736B-              core_msg1        db  'Core task created.',0x0d,0x0a,0
   735 000009C8 20637265617465642E-
   735 000009D1 0D0A00             
   736                                                   
   737 000009D4 5B434F524520544153-              core_msg2        db  '[CORE TASK]: I am working!',0x0d,0x0a,0
   737 000009DD 4B5D3A204920616D20-
   737 000009E6 776F726B696E67210D-
   737 000009EF 0A00               
   738                                  
   739                                  ;===============================================================================
   740                                  SECTION core_code vfollows=core_data
   741                                  ;-------------------------------------------------------------------------------
   742                                  load_relocate_program:                      ;加载并重定位用户程序
   743                                                                              ;输入: PUSH 逻辑扇区号
   744                                                                              ;      PUSH 任务控制块基地址
   745                                                                              ;输出：无 
   746 00000000 60                               pushad
   747                                        
   748 00000001 89E5                             mov ebp,esp                        ;为访问通过堆栈传递的参数做准备
   749                                        
   750                                           ;清空当前页目录的前半部分（对应低2GB的局部地址空间）
   751 00000003 BB00F0FFFF                       mov ebx,0xfffff000
   752 00000008 31F6                             xor esi,esi
   753                                    .clsp:
   754 0000000A C704B300000000                   mov dword [ebx+esi*4],0x00000000
   755 00000011 46                               inc esi
   756 00000012 81FE00020000                     cmp esi,512
   757 00000018 7CF0                             jl .clsp
   758                                  
   759 0000001A 0F20DB                           mov ebx,cr3                        ;刷新TLB
   760 0000001D 0F22DB                           mov cr3,ebx
   761                                  
   762                                           ;以下开始加载用户程序
   763 00000020 8B4528                           mov eax,[ebp+10*4]                 ;从堆栈中取出用户程序起始扇区号
   764 00000023 BB[3B010000]                     mov ebx,core_buf                   ;读取程序头部数据
   765 00000028 E8(B1000000)                     call read_hard_disk_0
   766                                  
   767                                           ;以下判断整个程序有多大
   768 0000002D A1[3B010000]                     mov eax,[core_buf]                 ;程序尺寸
   769 00000032 89C3                             mov ebx,eax
   770 00000034 81E300FEFFFF                     and ebx,0xfffffe00                 ;使之512字节对齐（能被512整除的数低
   771 0000003A 81C300020000                     add ebx,512                        ;9位都为0
   772 00000040 A9FF010000                       test eax,0x000001ff                ;程序的大小正好是512的倍数吗?
   773 00000045 0F45C3                           cmovnz eax,ebx                     ;不是。使用凑整的结果
   774                                  
   775 00000048 8B7524                           mov esi,[ebp+9*4]                  ;从堆栈中取得TCB的基地址
   776                                  
   777 0000004B 89C1                             mov ecx,eax                        ;实际需要申请的内存数量
   778 0000004D 89F3                             mov ebx,esi
   779 0000004F E8(5E020000)                     call task_alloc_memory
   780                                  
   781 00000054 89CB                             mov ebx,ecx                        ;ebx -> 申请到的内存首地址 == 0
   782 00000056 31D2                             xor edx,edx
   783 00000058 B900020000                       mov ecx,512
   784 0000005D F7F1                             div ecx
   785 0000005F 89C1                             mov ecx,eax                        ;总扇区数
   786                                  
   787 00000061 8B4528                           mov eax,[ebp+10*4]                 ;起始扇区号
   788                                    .b1:
   789 00000064 E8(B1000000)                     call read_hard_disk_0
   790 00000069 40                               inc eax
   791 0000006A E2F8                             loop .b1                           ;循环读，直到读完整个用户程序
   792                                  
   793                                           ;为用户任务分配栈空间
   794 0000006C 89F3                             mov ebx,esi                        ;TCB的线性地址
   795 0000006E B900100000                       mov ecx,4096                       ;4KB的空间
   796 00000073 E8(5E020000)                     call task_alloc_memory
   797 00000078 8B4E06                           mov ecx, [esi + 6]                 ;下一次分配的起始线性地址就是栈顶指针
   798 0000007B 894E46                           mov dword [esi + 70], ecx
   799                                  
   800                                           ;创建用于中断和调用门的0特权级栈空间
   801 0000007E 89F3                             mov ebx,esi
   802 00000080 B900100000                       mov ecx,4096                       ;4KB的空间
   803 00000085 E8(5E020000)                     call task_alloc_memory
   804 0000008A 8B4E06                           mov ecx, [esi + 6]                 ;下一次分配的起始线性地址就是栈顶指针
   805 0000008D 894E0A                           mov dword [esi + 10], ecx          ;TCB的ESP0域
   806                                  
   807                                           ;创建用户任务的页目录
   808                                           ;注意！页的分配和使用是由页位图决定的，可以不占用线性地址空间
   809 00000090 E8(2C020000)                     call create_copy_cur_pdir
   810 00000095 894616                           mov [esi + 22], eax                ;填写TCB的CR3(PDBR)域
   811                                  
   812 00000098 66C7461E1B00                     mov word [esi + 30], flat_user_code_seg_sel    ;TCB的CS域
   813 0000009E 66C746202300                     mov word [esi + 32], flat_user_data_seg_sel    ;TCB的SS域
   814 000000A4 66C746222300                     mov word [esi + 34], flat_user_data_seg_sel    ;TCB的DS域
   815 000000AA 66C746242300                     mov word [esi + 36], flat_user_data_seg_sel    ;TCB的ES域
   816 000000B0 66C746262300                     mov word [esi + 38], flat_user_data_seg_sel    ;TCB的FS域
   817 000000B6 66C746282300                     mov word [esi + 40], flat_user_data_seg_sel    ;TCB的GS域
   818 000000BC A104000000                       mov eax, [0x04]                    ;从任务的4GB地址空间获取入口点
   819 000000C1 89461A                           mov [esi + 26], eax                ;填写TCB的EIP域
   820 000000C4 9C                               pushfd
   821 000000C5 8F464A                           pop dword [esi + 74]               ;填写TCB的EFLAGS域
   822 000000C8 66C746040000                     mov word [esi + 4], 0              ;任务状态：就绪
   823                                  
   824 000000CE 61                               popad
   825                                        
   826 000000CF C20800                           ret 8                              ;丢弃调用本过程前压入的参数 
   827                                        
   828                                  ;-------------------------------------------------------------------------------
   829                                  append_to_tcb_link:                         ;在TCB链上追加任务控制块
   830                                                                              ;输入：ECX=TCB线性基地址
   831 000000D2 50                               push eax
   832 000000D3 52                               push edx
   833                                  
   834 000000D4 9C                               pushfd
   835 000000D5 FA                               cli
   836                                  
   837 000000D6 C70100000000                     mov dword [ecx+0x00],0             ;当前TCB指针域清零，以指示这是最
   838                                                                              ;后一个TCB
   839                                                                               
   840 000000DC A1[3B090000]                     mov eax,[tcb_chain]                ;TCB表头指针
   841 000000E1 09C0                             or eax,eax                         ;链表为空？
   842 000000E3 740D                             jz .notcb 
   843                                           
   844                                    .searc:
   845 000000E5 89C2                             mov edx,eax
   846 000000E7 8B02                             mov eax,[edx+0x00]
   847 000000E9 09C0                             or eax,eax               
   848 000000EB 75F8                             jnz .searc
   849                                  
   850 000000ED 26890A                           mov [es: edx+0x00],ecx
   851 000000F0 EB06                             jmp .retpc
   852                                           
   853                                    .notcb:       
   854 000000F2 890D[3B090000]                   mov [tcb_chain],ecx                ;若为空表，直接令表头指针指向TCB
   855                                           
   856                                    .retpc:
   857 000000F8 9D                               popfd
   858                                  
   859 000000F9 5A                               pop edx
   860 000000FA 58                               pop eax
   861                                           
   862 000000FB C3                               ret
   863                                           
   864                                  ;-------------------------------------------------------------------------------
   865                                  start:
   866                                           ;创建中断描述符表IDT
   867 000000FC BB[64000000]                     mov ebx, message_0
   868 00000101 E8(00000000)                     call put_string
   869                                  
   870                                           ;前20个向量是处理器异常使用的
   871 00000106 B8[C4030000]                     mov eax,general_exception_handler  ;门代码在段内偏移地址
   872 0000010B 66BB0800                         mov bx,flat_core_code_seg_sel      ;门代码所在段的选择子
   873 0000010F 66B9008E                         mov cx,0x8e00                      ;32位中断门，0特权级
   874 00000113 E8(7C010000)                     call make_gate_descriptor
   875                                  
   876 00000118 BB00F00180                       mov ebx,idt_linear_address         ;中断描述符表的线性地址
   877 0000011D 31F6                             xor esi,esi
   878                                    .idt0:
   879 0000011F 8904F3                           mov [ebx+esi*8],eax
   880 00000122 8954F304                         mov [ebx+esi*8+4],edx
   881 00000126 46                               inc esi
   882 00000127 83FE13                           cmp esi,19                         ;安装前20个异常中断处理过程
   883 0000012A 7EF3                             jle .idt0
   884                                  
   885                                           ;其余为保留或硬件使用的中断向量
   886 0000012C B8[BB030000]                     mov eax,general_interrupt_handler  ;门代码在段内偏移地址
   887 00000131 66BB0800                         mov bx,flat_core_code_seg_sel      ;门代码所在段的选择子
   888 00000135 66B9008E                         mov cx,0x8e00                      ;32位中断门，0特权级
   889 00000139 E8(7C010000)                     call make_gate_descriptor
   890                                  
   891 0000013E BB00F00180                       mov ebx,idt_linear_address         ;中断描述符表的线性地址
   892                                    .idt1:
   893 00000143 8904F3                           mov [ebx+esi*8],eax
   894 00000146 8954F304                         mov [ebx+esi*8+4],edx
   895 0000014A 46                               inc esi
   896 0000014B 81FEFF000000                     cmp esi,255                        ;安装普通的中断处理过程
   897 00000151 7EF0                             jle .idt1
   898                                  
   899                                           ;设置实时时钟中断处理过程
   900 00000153 B8[D0030000]                     mov eax,rtm_0x70_interrupt_handle  ;门代码在段内偏移地址
   901 00000158 66BB0800                         mov bx,flat_core_code_seg_sel      ;门代码所在段的选择子
   902 0000015C 66B9008E                         mov cx,0x8e00                      ;32位中断门，0特权级
   903 00000160 E8(7C010000)                     call make_gate_descriptor
   904                                  
   905 00000165 BB00F00180                       mov ebx,idt_linear_address         ;中断描述符表的线性地址
   906 0000016A 898380030000                     mov [ebx+0x70*8],eax               ;中断向量：0x70
   907 00000170 899384030000                     mov [ebx+0x70*8+4],edx
   908                                  
   909                                           ;设置系统调用中断的处理过程
   910 00000176 B8[E5030000]                     mov eax,int_0x88_handler           ;门代码在段内偏移地址
   911 0000017B 66BB0800                         mov bx,flat_core_code_seg_sel      ;门代码所在段的选择子
   912 0000017F 66B900EE                         mov cx,0xee00                      ;32位中断门，3特权级!!!!!!
   913 00000183 E8(7C010000)                     call make_gate_descriptor
   914                                  
   915 00000188 BB00F00180                       mov ebx,idt_linear_address         ;中断描述符表的线性地址
   916 0000018D 898340040000                     mov [ebx+0x88*8],eax               ;中断向量：0x88
   917 00000193 899344040000                     mov [ebx+0x88*8+4],edx
   918                                  
   919                                           ;准备开放中断
   920 00000199 66C705[06000000]FF-              mov word [pidt],256*8-1            ;IDT的界限
   920 000001A1 07                 
   921 000001A2 C705[08000000]00F0-              mov dword [pidt+2],idt_linear_address
   921 000001AA 0180               
   922 000001AC 0F011D[06000000]                 lidt [pidt]                        ;加载中断描述符表寄存器IDTR
   923                                  
   924                                           ;测试系统调用
   925 000001B3 BB[91000000]                     mov ebx,message_1
   926 000001B8 B800000000                       mov eax, 0                         ;通过系统调用的0号功能显示信息
   927 000001BD CD88                             int 0x88                           ;尽管TSS尚未准备好，但不会切换栈
   928                                  
   929                                           ;设置8259A中断控制器
   930 000001BF B011                             mov al,0x11
   931 000001C1 E620                             out 0x20,al                        ;ICW1：边沿触发/级联方式
   932 000001C3 B020                             mov al,0x20
   933 000001C5 E621                             out 0x21,al                        ;ICW2:起始中断向量
   934 000001C7 B004                             mov al,0x04
   935 000001C9 E621                             out 0x21,al                        ;ICW3:从片级联到IR2
   936 000001CB B001                             mov al,0x01
   937 000001CD E621                             out 0x21,al                        ;ICW4:非总线缓冲，全嵌套，正常EOI
   938                                  
   939 000001CF B011                             mov al,0x11
   940 000001D1 E6A0                             out 0xa0,al                        ;ICW1：边沿触发/级联方式
   941 000001D3 B070                             mov al,0x70
   942 000001D5 E6A1                             out 0xa1,al                        ;ICW2:起始中断向量
   943 000001D7 B004                             mov al,0x04
   944 000001D9 E6A1                             out 0xa1,al                        ;ICW3:从片级联到IR2
   945 000001DB B001                             mov al,0x01
   946 000001DD E6A1                             out 0xa1,al                        ;ICW4:非总线缓冲，全嵌套，正常EOI
   947                                  
   948                                           ;设置和时钟中断相关的硬件
   949 000001DF B00B                             mov al,0x0b                        ;RTC寄存器B
   950 000001E1 0C80                             or al,0x80                         ;阻断NMI
   951 000001E3 E670                             out 0x70,al
   952 000001E5 B012                             mov al,0x12                        ;设置寄存器B，禁止周期性中断，开放更
   953 000001E7 E671                             out 0x71,al                        ;新结束后中断，BCD码，24小时制
   954                                  
   955 000001E9 E4A1                             in al,0xa1                         ;读8259从片的IMR寄存器
   956 000001EB 24FE                             and al,0xfe                        ;清除bit 0(此位连接RTC)
   957 000001ED E6A1                             out 0xa1,al                        ;写回此寄存器
   958                                  
   959 000001EF B00C                             mov al,0x0c
   960 000001F1 E670                             out 0x70,al
   961 000001F3 E471                             in al,0x71                         ;读RTC寄存器C，复位未决的中断状态
   962                                  
   963 000001F5 FB                               sti                                ;开放硬件中断
   964                                  
   965                                           ;显示处理器品牌信息
   966 000001F6 B802000080                       mov eax,0x80000002
   967 000001FB 0FA2                             cpuid
   968 000001FD A3[B0000000]                     mov [cpu_brand + 0x00],eax
   969 00000202 891D[B4000000]                   mov [cpu_brand + 0x04],ebx
   970 00000208 890D[B8000000]                   mov [cpu_brand + 0x08],ecx
   971 0000020E 8915[BC000000]                   mov [cpu_brand + 0x0c],edx
   972                                  
   973 00000214 B803000080                       mov eax,0x80000003
   974 00000219 0FA2                             cpuid
   975 0000021B A3[C0000000]                     mov [cpu_brand + 0x10],eax
   976 00000220 891D[C4000000]                   mov [cpu_brand + 0x14],ebx
   977 00000226 890D[C8000000]                   mov [cpu_brand + 0x18],ecx
   978 0000022C 8915[CC000000]                   mov [cpu_brand + 0x1c],edx
   979                                  
   980 00000232 B804000080                       mov eax,0x80000004
   981 00000237 0FA2                             cpuid
   982 00000239 A3[D0000000]                     mov [cpu_brand + 0x20],eax
   983 0000023E 891D[D4000000]                   mov [cpu_brand + 0x24],ebx
   984 00000244 890D[D8000000]                   mov [cpu_brand + 0x28],ecx
   985 0000024A 8915[DC000000]                   mov [cpu_brand + 0x2c],edx
   986                                  
   987 00000250 BB[AB000000]                     mov ebx,cpu_brnd0                  ;显示处理器品牌信息
   988 00000255 E8(00000000)                     call put_string
   989 0000025A BB[B0000000]                     mov ebx,cpu_brand
   990 0000025F E8(00000000)                     call put_string
   991 00000264 BB[E4000000]                     mov ebx,cpu_brnd1
   992 00000269 E8(00000000)                     call put_string
   993                                  
   994                                           ;创建任务状态段TSS的描述符。整个系统实际上只需要一个TSS即可。
   995 0000026E B920000000                       mov ecx, 32
   996 00000273 31DB                             xor ebx, ebx
   997                                    .clear:
   998 00000275 C783[3F090000]0000-              mov dword [tss + ebx], 0          ;TSS的多数字段已经不用，全部清空。
   998 0000027D 0000               
   999 0000027F 83C304                           add ebx, 4
  1000 00000282 E2F1                             loop .clear
  1001                                  
  1002                                           ;因特权级之间的转移而发生栈切换时，本系统只会发生3到0的切换。因此，
  1003                                           ;只需要TSS中设置SS0，且必须是0特权级的栈段选择子。
  1004 00000284 66C705[47090000]10-              mov word [tss + 8], flat_core_data_seg_sel
  1004 0000028C 00                 
  1005                                  
  1006                                           ;创建TSS描述符，并安装到GDT中
  1007 0000028D B8[3F090000]                     mov eax,tss                        ;TSS的起始线性地址
  1008 00000292 BB67000000                       mov ebx,103                        ;段长度（界限）
  1009 00000297 B900890000                       mov ecx,0x00008900                 ;TSS描述符，特权级0
  1010 0000029C E8(61010000)                     call make_seg_descriptor
  1011 000002A1 E8(19010000)                     call set_up_gdt_descriptor
  1012                                  
  1013                                           ;令任务寄存器TR指向唯一的TSS并不再改变。
  1014 000002A6 0F00D9                           ltr cx
  1015                                  
  1016 000002A9 BB[99000000]                     mov ebx,message_2
  1017 000002AE E8(00000000)                     call put_string
  1018                                  
  1019                                           ;开始创建和确立内核任务
  1020 000002B3 B900F80180                       mov ecx, core_lin_tcb_addr         ;移至高端之后的内核任务TCB线性地址
  1021 000002B8 66C74104FFFF                     mov word [ecx + 4], 0xffff         ;任务的状态为“忙”
  1022 000002BE C7410600001080                   mov dword [ecx + 6], core_lin_alloc_at ;登记内核中可用于分配的起始线性地址
  1023 000002C5 E808FEFFFF                       call append_to_tcb_link            ;将内核任务的TCB添加到TCB链中
  1024                                  
  1025                                           ;现在可认为“程序管理器”任务正执行中
  1026 000002CA BB[BF090000]                     mov ebx,core_msg1
  1027 000002CF E8(00000000)                     call put_string
  1028                                  
  1029                                           ;以下开始创建用户任务
  1030 000002D4 B980000000                       mov ecx, 128                       ;为TCB分配内存
  1031 000002D9 E8(9A020000)                     call allocate_memory
  1032 000002DE 66C741040000                     mov word [ecx+0x04],0              ;任务状态：就绪
  1033 000002E4 C7410600000000                   mov dword [ecx+0x06],0             ;任务内可用于分配的初始线性地址
  1034                                  
  1035 000002EB 6A32                             push dword 50                      ;用户程序位于逻辑50扇区
  1036 000002ED 51                               push ecx                           ;压入任务控制块起始线性地址 
  1037 000002EE E80DFDFFFF                       call load_relocate_program
  1038 000002F3 E8DAFDFFFF                       call append_to_tcb_link            ;将此TCB添加到TCB链中
  1039                                  
  1040                                           ;可以创建更多的任务，例如：
  1041 000002F8 B980000000                       mov ecx,128                        ;为TCB分配内存
  1042 000002FD E8(9A020000)                     call allocate_memory
  1043 00000302 66C741040000                     mov word [ecx+0x04],0              ;任务状态：空闲
  1044 00000308 C7410600000000                   mov dword [ecx+0x06],0             ;任务内可用于分配的初始线性地址
  1045                                  
  1046 0000030F 6A64                             push dword 100                     ;用户程序位于逻辑100扇区
  1047 00000311 51                               push ecx                           ;压入任务控制块起始线性地址
  1048                                  
  1049 00000312 E8E9FCFFFF                       call load_relocate_program
  1050 00000317 E8B6FDFFFF                       call append_to_tcb_link            ;将此TCB添加到TCB链中
  1051                                  
  1052                                    .do_switch:
  1053 0000031C BB[D4090000]                     mov ebx,core_msg2
  1054 00000321 E8(00000000)                     call put_string
  1055                                  
  1056                                           ;清理已经终止的任务，并回收它们占用的资源
  1057 00000326 E8(E4030000)                     call do_task_clean
  1058                                  
  1059 0000032B F4                               hlt
  1060                                  
  1061 0000032C EBEE                             jmp .do_switch
  1062                                  
  1063                                  ;-------------------------------------------------------------------------------
  1064                                  SECTION core_tail
  1065                                  ;-------------------------------------------------------------------------------
  1066                                  core_end:
