     1                                           ;代码清单15-2，文件名：c15_core.asm
     2                                           ;文件说明：保护模式微型核心程序
     3                                           ;修改于2022-02-28
     4                                  
     5                                  ;-------------------------------------------------------------------------------
     6                                           ;以下常量定义部分。内核的大部分内容都应当固定 
     7                                           core_code_seg_sel     equ  0x38    ;内核代码段选择子
     8                                           core_data_seg_sel     equ  0x30    ;内核数据段选择子 
     9                                           sys_routine_seg_sel   equ  0x28    ;系统公共例程代码段的选择子 
    10                                           video_ram_seg_sel     equ  0x20    ;视频显示缓冲区的段选择子
    11                                           core_stack_seg_sel    equ  0x18    ;内核堆栈段选择子
    12                                           mem_0_4_gb_seg_sel    equ  0x08    ;整个0-4GB内存的段的选择子
    13                                  
    14                                  ;-------------------------------------------------------------------------------
    15                                           ;以下是系统核心的头部，用于加载核心程序 
    16 00000000 [00000000]                       core_length      dd core_end       ;核心程序总长度#00
    17                                  
    18 00000004 [00000000]                       sys_routine_seg  dd section.sys_routine.start
    19                                                                              ;系统公用例程段位置#04
    20                                  
    21 00000008 [00000000]                       core_data_seg    dd section.core_data.start
    22                                                                              ;核心数据段位置#08
    23                                  
    24 0000000C [00000000]                       core_code_seg    dd section.core_code.start
    25                                                                              ;核心代码段位置#0c
    26                                  
    27                                  
    28 00000010 [49010000]                       core_entry       dd start          ;核心代码段入口点#10
    29 00000014 3800                                              dw core_code_seg_sel
    30                                  
    31                                  ;===============================================================================
    32                                           [bits 32]
    33                                  ;===============================================================================
    34                                  SECTION sys_routine vstart=0                ;系统公共例程代码段 
    35                                  ;-------------------------------------------------------------------------------
    36                                           ;字符串显示例程
    37                                  put_string:                                 ;显示0终止的字符串并移动光标 
    38                                                                              ;输入：DS:EBX=串地址
    39 00000000 51                               push ecx
    40                                    .getc:
    41 00000001 8A0B                             mov cl,[ebx]
    42 00000003 08C9                             or cl,cl
    43 00000005 7408                             jz .exit
    44 00000007 E805000000                       call put_char
    45 0000000C 43                               inc ebx
    46 0000000D EBF2                             jmp .getc
    47                                  
    48                                    .exit:
    49 0000000F 59                               pop ecx
    50 00000010 CB                               retf                               ;段间返回
    51                                  
    52                                  ;-------------------------------------------------------------------------------
    53                                  put_char:                                   ;在当前光标处显示一个字符,并推进
    54                                                                              ;光标。仅用于段内调用 
    55                                                                              ;输入：CL=字符ASCII码 
    56 00000011 60                               pushad
    57                                  
    58                                           ;以下取当前光标位置
    59 00000012 66BAD403                         mov dx,0x3d4
    60 00000016 B00E                             mov al,0x0e
    61 00000018 EE                               out dx,al
    62 00000019 6642                             inc dx                             ;0x3d5
    63 0000001B EC                               in al,dx                           ;高字
    64 0000001C 88C4                             mov ah,al
    65                                  
    66 0000001E 664A                             dec dx                             ;0x3d4
    67 00000020 B00F                             mov al,0x0f
    68 00000022 EE                               out dx,al
    69 00000023 6642                             inc dx                             ;0x3d5
    70 00000025 EC                               in al,dx                           ;低字
    71 00000026 6689C3                           mov bx,ax                          ;BX=代表光标位置的16位数
    72                                  
    73 00000029 80F90D                           cmp cl,0x0d                        ;回车符？
    74 0000002C 750E                             jnz .put_0a
    75 0000002E 6689D8                           mov ax,bx
    76 00000031 B350                             mov bl,80
    77 00000033 F6F3                             div bl
    78 00000035 F6E3                             mul bl
    79 00000037 6689C3                           mov bx,ax
    80 0000003A EB65                             jmp .set_cursor
    81                                  
    82                                    .put_0a:
    83 0000003C 80F90A                           cmp cl,0x0a                        ;换行符？
    84 0000003F 7506                             jnz .put_other
    85 00000041 6683C350                         add bx,80
    86 00000045 EB15                             jmp .roll_screen
    87                                  
    88                                    .put_other:                               ;正常显示字符
    89 00000047 06                               push es
    90 00000048 B820000000                       mov eax,video_ram_seg_sel          ;0xb8000段的选择子
    91 0000004D 8EC0                             mov es,eax
    92 0000004F 66D1E3                           shl bx,1
    93 00000052 2667880F                         mov [es:bx],cl
    94 00000056 07                               pop es
    95                                  
    96                                           ;以下将光标位置推进一个字符
    97 00000057 66D1EB                           shr bx,1
    98 0000005A 6643                             inc bx
    99                                  
   100                                    .roll_screen:
   101 0000005C 6681FBD007                       cmp bx,2000                        ;光标超出屏幕？滚屏
   102 00000061 7C3E                             jl .set_cursor
   103                                  
   104 00000063 6653                             push bx                            ;为了修改原书程序的逻辑问题，新增
   105 00000065 1E                               push ds
   106 00000066 06                               push es
   107 00000067 B820000000                       mov eax,video_ram_seg_sel
   108 0000006C 8ED8                             mov ds,eax
   109 0000006E 8EC0                             mov es,eax
   110 00000070 FC                               cld
   111 00000071 BEA0000000                       mov esi,0xa0                       ;小心！32位模式下movsb/w/d 
   112 00000076 BF00000000                       mov edi,0x00                       ;使用的是esi/edi/ecx 
   113 0000007B B980070000                       mov ecx,1920
   114 00000080 F366A5                           rep movsw
   115 00000083 66BB000F                         mov bx,3840                        ;清除屏幕最底一行
   116 00000087 B950000000                       mov ecx,80                         ;32位程序应该使用ECX
   117                                    .cls:
   118 0000008C 266667C7072007                   mov word[es:bx],0x0720
   119 00000093 6683C302                         add bx,2
   120 00000097 E2F3                             loop .cls
   121                                  
   122 00000099 07                               pop es
   123 0000009A 1F                               pop ds
   124                                  
   125                                           ;mov bx,1920                       ;为了修改原书程序的逻辑问题，删除
   126 0000009B 665B                             pop bx                             ;为了修改原书程序的逻辑问题，新增
   127 0000009D 6683EB50                         sub bx,80                          ;为了修改原书程序的逻辑问题，新增
   128                                  
   129                                    .set_cursor:
   130 000000A1 66BAD403                         mov dx,0x3d4
   131 000000A5 B00E                             mov al,0x0e
   132 000000A7 EE                               out dx,al
   133 000000A8 6642                             inc dx                             ;0x3d5
   134 000000AA 88F8                             mov al,bh
   135 000000AC EE                               out dx,al
   136 000000AD 664A                             dec dx                             ;0x3d4
   137 000000AF B00F                             mov al,0x0f
   138 000000B1 EE                               out dx,al
   139 000000B2 6642                             inc dx                             ;0x3d5
   140 000000B4 88D8                             mov al,bl
   141 000000B6 EE                               out dx,al
   142                                  
   143 000000B7 61                               popad
   144 000000B8 C3                               ret                                
   145                                  
   146                                  ;-------------------------------------------------------------------------------
   147                                  read_hard_disk_0:                           ;从硬盘读取一个逻辑扇区
   148                                                                              ;EAX=逻辑扇区号
   149                                                                              ;DS:EBX=目标缓冲区地址
   150                                                                              ;返回：EBX=EBX+512
   151 000000B9 50                               push eax 
   152 000000BA 51                               push ecx
   153 000000BB 52                               push edx
   154                                        
   155 000000BC 50                               push eax
   156                                           
   157 000000BD 66BAF201                         mov dx,0x1f2
   158 000000C1 B001                             mov al,1
   159 000000C3 EE                               out dx,al                          ;读取的扇区数
   160                                  
   161 000000C4 6642                             inc dx                             ;0x1f3
   162 000000C6 58                               pop eax
   163 000000C7 EE                               out dx,al                          ;LBA地址7~0
   164                                  
   165 000000C8 6642                             inc dx                             ;0x1f4
   166 000000CA B108                             mov cl,8
   167 000000CC D3E8                             shr eax,cl
   168 000000CE EE                               out dx,al                          ;LBA地址15~8
   169                                  
   170 000000CF 6642                             inc dx                             ;0x1f5
   171 000000D1 D3E8                             shr eax,cl
   172 000000D3 EE                               out dx,al                          ;LBA地址23~16
   173                                  
   174 000000D4 6642                             inc dx                             ;0x1f6
   175 000000D6 D3E8                             shr eax,cl
   176 000000D8 0CE0                             or al,0xe0                         ;第一硬盘  LBA地址27~24
   177 000000DA EE                               out dx,al
   178                                  
   179 000000DB 6642                             inc dx                             ;0x1f7
   180 000000DD B020                             mov al,0x20                        ;读命令
   181 000000DF EE                               out dx,al
   182                                  
   183                                    .waits:
   184 000000E0 EC                               in al,dx
   185 000000E1 2488                             and al,0x88
   186 000000E3 3C08                             cmp al,0x08
   187 000000E5 75F9                             jnz .waits                         ;不忙，且硬盘已准备好数据传输 
   188                                  
   189 000000E7 B900010000                       mov ecx,256                        ;总共要读取的字数
   190 000000EC 66BAF001                         mov dx,0x1f0
   191                                    .readw:
   192 000000F0 66ED                             in ax,dx
   193 000000F2 668903                           mov [ebx],ax
   194 000000F5 83C302                           add ebx,2
   195 000000F8 E2F6                             loop .readw
   196                                  
   197 000000FA 5A                               pop edx
   198 000000FB 59                               pop ecx
   199 000000FC 58                               pop eax
   200                                        
   201 000000FD CB                               retf                               ;段间返回 
   202                                  
   203                                  ;-------------------------------------------------------------------------------
   204                                  ;汇编语言程序是极难一次成功，而且调试非常困难。这个例程可以提供帮助
   205                                  put_hex_dword:                              ;在当前光标处以十六进制形式显示
   206                                                                              ;一个双字并推进光标
   207                                                                              ;输入：EDX=要转换并显示的数字
   208                                                                              ;输出：无
   209 000000FE 60                               pushad
   210 000000FF 1E                               push ds
   211                                  
   212 00000100 66B83000                         mov ax,core_data_seg_sel           ;切换到核心数据段
   213 00000104 8ED8                             mov ds,ax
   214                                  
   215 00000106 BB[06050000]                     mov ebx,bin_hex                    ;指向核心数据段内的转换表
   216 0000010B B908000000                       mov ecx,8
   217                                    .xlt:
   218 00000110 C1C204                           rol edx,4
   219 00000113 89D0                             mov eax,edx
   220 00000115 83E00F                           and eax,0x0000000f
   221 00000118 D7                               xlat
   222                                  
   223 00000119 51                               push ecx
   224 0000011A 88C1                             mov cl,al
   225 0000011C E8F0FEFFFF                       call put_char
   226 00000121 59                               pop ecx
   227                                  
   228 00000122 E2EC                             loop .xlt
   229                                  
   230 00000124 1F                               pop ds
   231 00000125 61                               popad
   232                                  
   233 00000126 CB                               retf
   234                                  
   235                                  ;-------------------------------------------------------------------------------
   236                                  allocate_memory:                            ;分配内存
   237                                                                              ;输入：ECX=希望分配的字节数
   238                                                                              ;输出：ECX=起始线性地址 
   239 00000127 1E                               push ds
   240 00000128 50                               push eax
   241 00000129 53                               push ebx
   242                                        
   243 0000012A B830000000                       mov eax,core_data_seg_sel
   244 0000012F 8ED8                             mov ds,eax
   245                                        
   246 00000131 A1[06000000]                     mov eax,[ram_alloc]
   247 00000136 01C8                             add eax,ecx                        ;下一次分配时的起始地址
   248                                        
   249                                           ;这里应当有检测可用内存数量的指令
   250                                            
   251 00000138 8B0D[06000000]                   mov ecx,[ram_alloc]                ;返回分配的起始地址
   252                                  
   253 0000013E 89C3                             mov ebx,eax
   254 00000140 83E3FC                           and ebx,0xfffffffc
   255 00000143 83C304                           add ebx,4                          ;强制对齐 
   256 00000146 A903000000                       test eax,0x00000003                ;下次分配的起始地址最好是4字节对齐
   257 0000014B 0F45C3                           cmovnz eax,ebx                     ;如果没有对齐，则强制对齐 
   258 0000014E A3[06000000]                     mov [ram_alloc],eax                ;下次从该地址分配内存
   259                                                                              ;cmovcc指令可以避免控制转移 
   260 00000153 5B                               pop ebx
   261 00000154 58                               pop eax
   262 00000155 1F                               pop ds
   263                                  
   264 00000156 CB                               retf
   265                                  
   266                                  ;-------------------------------------------------------------------------------
   267                                  set_up_gdt_descriptor:                      ;在GDT内安装一个新的描述符
   268                                                                              ;输入：EDX:EAX=描述符 
   269                                                                              ;输出：CX=描述符的选择子
   270 00000157 50                               push eax
   271 00000158 53                               push ebx
   272 00000159 52                               push edx
   273                                        
   274 0000015A 1E                               push ds
   275 0000015B 06                               push es
   276                                        
   277 0000015C BB30000000                       mov ebx,core_data_seg_sel          ;切换到核心数据段
   278 00000161 8EDB                             mov ds,ebx
   279                                  
   280 00000163 0F0105[00000000]                 sgdt [pgdt]                        ;以便开始处理GDT
   281                                  
   282 0000016A BB08000000                       mov ebx,mem_0_4_gb_seg_sel
   283 0000016F 8EC3                             mov es,ebx
   284                                  
   285 00000171 0FB71D[00000000]                 movzx ebx,word [pgdt]              ;GDT界限 
   286 00000178 6643                             inc bx                             ;GDT总字节数，也是下一个描述符偏移 
   287 0000017A 031D[02000000]                   add ebx,[pgdt+2]                   ;下一个描述符的线性地址 
   288                                        
   289 00000180 268903                           mov [es:ebx],eax
   290 00000183 26895304                         mov [es:ebx+4],edx
   291                                        
   292 00000187 668305[00000000]08               add word [pgdt],8                  ;增加一个描述符的大小   
   293                                        
   294 0000018F 0F0115[00000000]                 lgdt [pgdt]                        ;对GDT的更改生效 
   295                                         
   296 00000196 66A1[00000000]                   mov ax,[pgdt]                      ;得到GDT界限值
   297 0000019C 6631D2                           xor dx,dx
   298 0000019F 66BB0800                         mov bx,8
   299 000001A3 66F7F3                           div bx                             ;除以8，去掉余数
   300 000001A6 6689C1                           mov cx,ax                          
   301 000001A9 66C1E103                         shl cx,3                           ;将索引号移到正确位置 
   302                                  
   303 000001AD 07                               pop es
   304 000001AE 1F                               pop ds
   305                                  
   306 000001AF 5A                               pop edx
   307 000001B0 5B                               pop ebx
   308 000001B1 58                               pop eax
   309                                        
   310 000001B2 CB                               retf 
   311                                  ;-------------------------------------------------------------------------------
   312                                  make_seg_descriptor:                        ;构造存储器和系统的段描述符
   313                                                                              ;输入：EAX=线性基地址
   314                                                                              ;      EBX=段界限
   315                                                                              ;      ECX=属性。各属性位都在原始
   316                                                                              ;          位置，无关的位清零 
   317                                                                              ;返回：EDX:EAX=描述符
   318 000001B3 89C2                             mov edx,eax
   319 000001B5 C1E010                           shl eax,16
   320 000001B8 6609D8                           or ax,bx                           ;描述符前32位(EAX)构造完毕
   321                                  
   322 000001BB 81E20000FFFF                     and edx,0xffff0000                 ;清除基地址中无关的位
   323 000001C1 C1C208                           rol edx,8
   324 000001C4 0FCA                             bswap edx                          ;装配基址的31~24和23~16  (80486+)
   325                                  
   326 000001C6 6631DB                           xor bx,bx
   327 000001C9 09DA                             or edx,ebx                         ;装配段界限的高4位
   328                                  
   329 000001CB 09CA                             or edx,ecx                         ;装配属性
   330                                  
   331 000001CD CB                               retf
   332                                  
   333                                  ;===============================================================================
   334                                  SECTION core_data vstart=0                  ;系统核心的数据段
   335                                  ;-------------------------------------------------------------------------------
   336 00000000 0000                             pgdt             dw  0             ;用于设置和修改GDT 
   337 00000002 00000000                                          dd  0
   338                                  
   339 00000006 00001000                         ram_alloc        dd  0x00100000    ;下次分配内存时的起始地址
   340                                  
   341                                           ;符号地址检索表
   342                                           salt:
   343 0000000A 405072696E74537472-              salt_1           db  '@PrintString'
   343 00000013 696E67             
   344 00000016 00<rep F4h>                                  times 256-($-salt_1) db 0
   345 0000010A [00000000]                                        dd  put_string
   346 0000010E 2800                                              dw  sys_routine_seg_sel
   347                                  
   348 00000110 40526561644469736B-              salt_2           db  '@ReadDiskData'
   348 00000119 44617461           
   349 0000011D 00<rep F3h>                                  times 256-($-salt_2) db 0
   350 00000210 [B9000000]                                        dd  read_hard_disk_0
   351 00000214 2800                                              dw  sys_routine_seg_sel
   352                                  
   353 00000216 405072696E7444776F-              salt_3           db  '@PrintDwordAsHexString'
   353 0000021F 726441734865785374-
   353 00000228 72696E67           
   354 0000022C 00<rep EAh>                                  times 256-($-salt_3) db 0
   355 00000316 [FE000000]                                        dd  put_hex_dword
   356 0000031A 2800                                              dw  sys_routine_seg_sel
   357                                  
   358 0000031C 405465726D696E6174-              salt_4           db  '@TerminateProgram'
   358 00000325 6550726F6772616D   
   359 0000032D 00<rep EFh>                                  times 256-($-salt_4) db 0
   360 0000041C [0A020000]                                        dd  return_point
   361 00000420 3800                                              dw  core_code_seg_sel
   362                                  
   363                                           salt_item_len   equ $-salt_4
   364                                           salt_items      equ ($-salt)/salt_item_len
   365                                  
   366 00000422 2020496620796F7520-              message_1        db  '  If you seen this message,that means we '
   366 0000042B 7365656E2074686973-
   366 00000434 206D6573736167652C-
   366 0000043D 74686174206D65616E-
   366 00000446 7320776520         
   367 0000044B 617265206E6F772069-                               db  'are now in protect mode,and the system '
   367 00000454 6E2070726F74656374-
   367 0000045D 206D6F64652C616E64-
   367 00000466 207468652073797374-
   367 0000046F 656D20             
   368 00000472 636F7265206973206C-                               db  'core is loaded,and the video display '
   368 0000047B 6F616465642C616E64-
   368 00000484 207468652076696465-
   368 0000048D 6F20646973706C6179-
   368 00000496 20                 
   369 00000497 726F7574696E652077-                               db  'routine works perfectly.',0x0d,0x0a,0
   369 000004A0 6F726B732070657266-
   369 000004A9 6563746C792E0D0A00 
   370                                  
   371 000004B2 20204C6F6164696E67-              message_5        db  '  Loading user program...',0
   371 000004BB 20757365722070726F-
   371 000004C4 6772616D2E2E2E00   
   372                                           
   373 000004CC 446F6E652E0D0A00                 do_status        db  'Done.',0x0d,0x0a,0
   374                                           
   375 000004D4 0D0A0D0A0D0A                     message_6        db  0x0d,0x0a,0x0d,0x0a,0x0d,0x0a
   376 000004DA 202055736572207072-                               db  '  User program terminated,control returned.',0
   376 000004E3 6F6772616D20746572-
   376 000004EC 6D696E617465642C63-
   376 000004F5 6F6E74726F6C207265-
   376 000004FE 7475726E65642E00   
   377                                  
   378 00000506 303132333435363738-              bin_hex          db '0123456789ABCDEF'
   378 0000050F 39414243444546     
   379                                                                              ;put_hex_dword子过程用的查找表
   380 00000516 00<rep 800h>                     core_buf   times 2048 db 0         ;内核用的缓冲区
   381                                  
   382 00000D16 00000000                         esp_pointer      dd 0              ;内核用来临时保存自己的栈指针     
   383                                  
   384 00000D1A 0D0A202000                       cpu_brnd0        db 0x0d,0x0a,'  ',0
   385 00000D1F 00<rep 31h>                      cpu_brand  times 49 db 0
   386 00000D50 0D0A0D0A00                       cpu_brnd1        db 0x0d,0x0a,0x0d,0x0a,0
   387                                  
   388                                  ;===============================================================================
   389                                  SECTION core_code vstart=0
   390                                  ;-------------------------------------------------------------------------------
   391                                  load_relocate_program:                      ;加载并重定位用户程序
   392                                                                              ;输入：ESI=起始逻辑扇区号
   393                                                                              ;返回：AX=指向用户程序头部的选择子 
   394 00000000 53                               push ebx
   395 00000001 51                               push ecx
   396 00000002 52                               push edx
   397 00000003 56                               push esi
   398 00000004 57                               push edi
   399                                        
   400 00000005 1E                               push ds
   401 00000006 06                               push es
   402                                        
   403 00000007 B830000000                       mov eax,core_data_seg_sel
   404 0000000C 8ED8                             mov ds,eax                         ;切换DS到内核数据段
   405                                  
   406 0000000E 89F0                             mov eax,esi                        ;读取程序头部数据 
   407 00000010 BB[16050000]                     mov ebx,core_buf                        
   408 00000015 9A[B9000000]2800                 call sys_routine_seg_sel:read_hard_disk_0
   409                                  
   410                                           ;以下判断整个程序有多大
   411 0000001C A1[16050000]                     mov eax,[core_buf]                 ;程序尺寸
   412 00000021 89C3                             mov ebx,eax
   413 00000023 81E300FEFFFF                     and ebx,0xfffffe00                 ;使之512字节对齐（能被512整除的数， 
   414 00000029 81C300020000                     add ebx,512                        ;低9位都为0 
   415 0000002F A9FF010000                       test eax,0x000001ff                ;程序的大小正好是512的倍数吗? 
   416 00000034 0F45C3                           cmovnz eax,ebx                     ;不是。使用凑整的结果 
   417                                        
   418 00000037 89C1                             mov ecx,eax                        ;实际需要申请的内存数量
   419 00000039 9A[27010000]2800                 call sys_routine_seg_sel:allocate_memory
   420 00000040 89CB                             mov ebx,ecx                        ;ebx -> 申请到的内存首地址
   421 00000042 53                               push ebx                           ;保存该首地址 
   422 00000043 31D2                             xor edx,edx
   423 00000045 B900020000                       mov ecx,512
   424 0000004A F7F1                             div ecx
   425 0000004C 89C1                             mov ecx,eax                        ;总扇区数 
   426                                        
   427 0000004E B808000000                       mov eax,mem_0_4_gb_seg_sel         ;切换DS到0-4GB的段
   428 00000053 8ED8                             mov ds,eax
   429                                  
   430 00000055 89F0                             mov eax,esi                        ;起始扇区号 
   431                                    .b1:
   432 00000057 9A[B9000000]2800                 call sys_routine_seg_sel:read_hard_disk_0
   433 0000005E 40                               inc eax
   434 0000005F E2F6                             loop .b1                           ;循环读，直到读完整个用户程序
   435                                  
   436                                           ;建立程序头部段描述符
   437 00000061 5F                               pop edi                            ;恢复程序装载的首地址 
   438 00000062 89F8                             mov eax,edi                        ;程序头部起始线性地址
   439 00000064 8B5F04                           mov ebx,[edi+0x04]                 ;段长度
   440 00000067 4B                               dec ebx                            ;段界限 
   441 00000068 B900924000                       mov ecx,0x00409200                 ;字节粒度的数据段描述符
   442 0000006D 9A[B3010000]2800                 call sys_routine_seg_sel:make_seg_descriptor
   443 00000074 9A[57010000]2800                 call sys_routine_seg_sel:set_up_gdt_descriptor
   444 0000007B 66894F04                         mov [edi+0x04],cx                   
   445                                  
   446                                           ;建立程序代码段描述符
   447 0000007F 89F8                             mov eax,edi
   448 00000081 03470C                           add eax,[edi+0x0c]                 ;代码起始线性地址
   449 00000084 8B5F10                           mov ebx,[edi+0x10]                 ;段长度
   450 00000087 4B                               dec ebx                            ;段界限
   451 00000088 B900984000                       mov ecx,0x00409800                 ;字节粒度的代码段描述符
   452 0000008D 9A[B3010000]2800                 call sys_routine_seg_sel:make_seg_descriptor
   453 00000094 9A[57010000]2800                 call sys_routine_seg_sel:set_up_gdt_descriptor
   454 0000009B 66894F0C                         mov [edi+0x0c],cx
   455                                  
   456                                           ;建立程序数据段描述符
   457 0000009F 89F8                             mov eax,edi
   458 000000A1 034714                           add eax,[edi+0x14]                 ;数据段起始线性地址
   459 000000A4 8B5F18                           mov ebx,[edi+0x18]                 ;段长度
   460 000000A7 4B                               dec ebx                            ;段界限
   461 000000A8 B900924000                       mov ecx,0x00409200                 ;字节粒度的数据段描述符
   462 000000AD 9A[B3010000]2800                 call sys_routine_seg_sel:make_seg_descriptor
   463 000000B4 9A[57010000]2800                 call sys_routine_seg_sel:set_up_gdt_descriptor
   464 000000BB 66894F14                         mov [edi+0x14],cx
   465                                  
   466                                           ;建立程序堆栈段描述符
   467 000000BF 89F8                             mov eax,edi
   468 000000C1 03471C                           add eax,[edi+0x1c]                 ;数据段起始线性地址
   469 000000C4 8B5F20                           mov ebx,[edi+0x20]                 ;段长度
   470 000000C7 4B                               dec ebx                            ;段界限
   471 000000C8 B900924000                       mov ecx,0x00409200                 ;字节粒度的数据段描述符
   472 000000CD 9A[B3010000]2800                 call sys_routine_seg_sel:make_seg_descriptor
   473 000000D4 9A[57010000]2800                 call sys_routine_seg_sel:set_up_gdt_descriptor
   474 000000DB 66894F1C                         mov [edi+0x1c],cx
   475                                  
   476                                           ;重定位SALT
   477 000000DF 8B4704                           mov eax,[edi+0x04]
   478 000000E2 8EC0                             mov es,eax                         ;es -> 用户程序头部
   479 000000E4 B830000000                       mov eax,core_data_seg_sel
   480 000000E9 8ED8                             mov ds,eax
   481                                  
   482 000000EB FC                               cld
   483                                  
   484 000000EC 268B0D24000000                   mov ecx,[es:0x24]                  ;用户程序的SALT条目数
   485 000000F3 BF28000000                       mov edi,0x28                       ;用户程序内的SALT位于头部内0x28处
   486                                    .b2:
   487 000000F8 51                               push ecx
   488 000000F9 57                               push edi
   489                                  
   490 000000FA B904000000                       mov ecx,salt_items
   491 000000FF BE[0A000000]                     mov esi,salt
   492                                    .b3:
   493 00000104 57                               push edi
   494 00000105 56                               push esi
   495 00000106 51                               push ecx
   496                                  
   497 00000107 B940000000                       mov ecx,64                         ;检索表中，每条目的比较次数
   498 0000010C F3A7                             repe cmpsd                         ;每次比较4字节
   499 0000010E 7515                             jnz .b4
   500 00000110 8B06                             mov eax,[esi]                      ;若匹配，esi恰好指向其后的地址数据
   501 00000112 26898700FFFFFF                   mov [es:edi-256],eax               ;将字符串改写成偏移地址
   502 00000119 668B4604                         mov ax,[esi+4]
   503 0000011D 2666898704FFFFFF                 mov [es:edi-252],ax                ;以及段选择子
   504                                    .b4:
   505                                  
   506 00000125 59                               pop ecx
   507 00000126 5E                               pop esi
   508 00000127 81C606010000                     add esi,salt_item_len
   509 0000012D 5F                               pop edi                            ;从头比较
   510 0000012E E2D4                             loop .b3
   511                                  
   512 00000130 5F                               pop edi
   513 00000131 81C700010000                     add edi,256
   514 00000137 59                               pop ecx
   515 00000138 E2BE                             loop .b2
   516                                  
   517 0000013A 2666A104000000                   mov ax,[es:0x04]
   518                                  
   519 00000141 07                               pop es                             ;恢复到调用此过程前的es段 
   520 00000142 1F                               pop ds                             ;恢复到调用此过程前的ds段
   521                                        
   522 00000143 5F                               pop edi
   523 00000144 5E                               pop esi
   524 00000145 5A                               pop edx
   525 00000146 59                               pop ecx
   526 00000147 5B                               pop ebx
   527                                        
   528 00000148 C3                               ret
   529                                        
   530                                  ;-------------------------------------------------------------------------------
   531                                  start:
   532 00000149 B930000000                       mov ecx,core_data_seg_sel           ;使ds指向核心数据段 
   533 0000014E 8ED9                             mov ds,ecx
   534                                           ;mov es,ecx ;在Hyper-V虚拟机上，不初始化ES的话，在put_char例程内操作ES会出问题。
   535 00000150 BB[22040000]                     mov ebx,message_1
   536 00000155 9A[00000000]2800                 call sys_routine_seg_sel:put_string
   537                                  
   538                                           ;显示处理器品牌信息 
   539 0000015C B802000080                       mov eax,0x80000002
   540 00000161 0FA2                             cpuid
   541 00000163 A3[1F0D0000]                     mov [cpu_brand + 0x00],eax
   542 00000168 891D[230D0000]                   mov [cpu_brand + 0x04],ebx
   543 0000016E 890D[270D0000]                   mov [cpu_brand + 0x08],ecx
   544 00000174 8915[2B0D0000]                   mov [cpu_brand + 0x0c],edx
   545                                        
   546 0000017A B803000080                       mov eax,0x80000003
   547 0000017F 0FA2                             cpuid
   548 00000181 A3[2F0D0000]                     mov [cpu_brand + 0x10],eax
   549 00000186 891D[330D0000]                   mov [cpu_brand + 0x14],ebx
   550 0000018C 890D[370D0000]                   mov [cpu_brand + 0x18],ecx
   551 00000192 8915[3B0D0000]                   mov [cpu_brand + 0x1c],edx
   552                                  
   553 00000198 B804000080                       mov eax,0x80000004
   554 0000019D 0FA2                             cpuid
   555 0000019F A3[3F0D0000]                     mov [cpu_brand + 0x20],eax
   556 000001A4 891D[430D0000]                   mov [cpu_brand + 0x24],ebx
   557 000001AA 890D[470D0000]                   mov [cpu_brand + 0x28],ecx
   558 000001B0 8915[4B0D0000]                   mov [cpu_brand + 0x2c],edx
   559                                  
   560 000001B6 BB[1A0D0000]                     mov ebx,cpu_brnd0
   561 000001BB 9A[00000000]2800                 call sys_routine_seg_sel:put_string
   562 000001C2 BB[1F0D0000]                     mov ebx,cpu_brand
   563 000001C7 9A[00000000]2800                 call sys_routine_seg_sel:put_string
   564 000001CE BB[500D0000]                     mov ebx,cpu_brnd1
   565 000001D3 9A[00000000]2800                 call sys_routine_seg_sel:put_string
   566                                  
   567 000001DA BB[B2040000]                     mov ebx,message_5
   568 000001DF 9A[00000000]2800                 call sys_routine_seg_sel:put_string
   569 000001E6 BE32000000                       mov esi,50                          ;用户程序位于逻辑50扇区 
   570 000001EB E810FEFFFF                       call load_relocate_program
   571                                        
   572 000001F0 BB[CC040000]                     mov ebx,do_status
   573 000001F5 9A[00000000]2800                 call sys_routine_seg_sel:put_string
   574                                        
   575 000001FC 8925[160D0000]                   mov [esp_pointer],esp               ;临时保存堆栈指针
   576                                         
   577 00000202 8ED8                             mov ds,ax
   578                                  
   579 00000204 FF2D08000000                     jmp far [0x08]                      ;控制权交给用户程序（入口点）
   580                                                                               ;堆栈可能切换 
   581                                  
   582                                  return_point:                                ;用户程序返回点
   583 0000020A B830000000                       mov eax,core_data_seg_sel           ;使ds指向核心数据段
   584 0000020F 8ED8                             mov ds,eax
   585                                  
   586 00000211 B818000000                       mov eax,core_stack_seg_sel          ;切换回内核自己的堆栈
   587 00000216 8ED0                             mov ss,eax 
   588 00000218 8B25[160D0000]                   mov esp,[esp_pointer]
   589                                  
   590 0000021E BB[D4040000]                     mov ebx,message_6
   591 00000223 9A[00000000]2800                 call sys_routine_seg_sel:put_string
   592                                  
   593                                           ;这里可以放置清除用户程序各种描述符的指令
   594                                           ;也可以加载并启动其它程序
   595                                         
   596 0000022A F4                               hlt
   597                                              
   598                                  ;===============================================================================
   599                                  SECTION core_trail
   600                                  ;-------------------------------------------------------------------------------
   601                                  core_end:
