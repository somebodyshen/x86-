     1                                           ;代码清单16-1
     2                                           ;文件名：c16_core.asm
     3                                           ;文件说明：保护模式微型核心程序 
     4                                           ;创建日期：2011-11-6 18:37
     5                                  
     6                                           ;以下常量定义部分。内核的大部分内容都应当固定 
     7                                           core_code_seg_sel     equ  0x38    ;内核代码段选择子
     8                                           core_data_seg_sel     equ  0x30    ;内核数据段选择子 
     9                                           sys_routine_seg_sel   equ  0x28    ;系统公共例程代码段的选择子 
    10                                           video_ram_seg_sel     equ  0x20    ;视频显示缓冲区的段选择子
    11                                           core_stack_seg_sel    equ  0x18    ;内核堆栈段选择子
    12                                           mem_0_4_gb_seg_sel    equ  0x08    ;整个0-4GB内存的段的选择子
    13                                  
    14                                  ;-------------------------------------------------------------------------------
    15                                           ;以下是系统核心的头部，用于加载核心程序 
    16 00000000 [00000000]                       core_length      dd core_end       ;核心程序总长度#00
    17                                  
    18 00000004 [00000000]                       sys_routine_seg  dd section.sys_routine.start
    19                                                                              ;系统公用例程段位置#04
    20                                  
    21 00000008 [00000000]                       core_data_seg    dd section.core_data.start
    22                                                                              ;核心数据段位置#08
    23                                  
    24 0000000C [00000000]                       core_code_seg    dd section.core_code.start
    25                                                                              ;核心代码段位置#0c
    26                                  
    27                                  
    28 00000010 [5C030000]                       core_entry       dd start          ;核心代码段入口点#10
    29 00000014 3800                                              dw core_code_seg_sel
    30                                  
    31                                  ;===============================================================================
    32                                           [bits 32]
    33                                  ;===============================================================================
    34                                  SECTION sys_routine vstart=0                ;系统公共例程代码段 
    35                                  ;-------------------------------------------------------------------------------
    36                                           ;字符串显示例程
    37                                  put_string:                                 ;显示0终止的字符串并移动光标 
    38                                                                              ;输入：DS:EBX=串地址
    39 00000000 51                               push ecx
    40                                    .getc:
    41 00000001 8A0B                             mov cl,[ebx]
    42 00000003 08C9                             or cl,cl
    43 00000005 7408                             jz .exit
    44 00000007 E805000000                       call put_char
    45 0000000C 43                               inc ebx
    46 0000000D EBF2                             jmp .getc
    47                                  
    48                                    .exit:
    49 0000000F 59                               pop ecx
    50 00000010 CB                               retf                               ;段间返回
    51                                  
    52                                  ;-------------------------------------------------------------------------------
    53                                  put_char:                                   ;在当前光标处显示一个字符,并推进
    54                                                                              ;光标。仅用于段内调用
    55                                                                              ;输入：CL=字符ASCII码
    56 00000011 60                               pushad
    57                                  
    58                                           ;以下取当前光标位置
    59 00000012 66BAD403                         mov dx,0x3d4
    60 00000016 B00E                             mov al,0x0e
    61 00000018 EE                               out dx,al
    62 00000019 6642                             inc dx                             ;0x3d5
    63 0000001B EC                               in al,dx                           ;高字
    64 0000001C 88C4                             mov ah,al
    65                                  
    66 0000001E 664A                             dec dx                             ;0x3d4
    67 00000020 B00F                             mov al,0x0f
    68 00000022 EE                               out dx,al
    69 00000023 6642                             inc dx                             ;0x3d5
    70 00000025 EC                               in al,dx                           ;低字
    71 00000026 6689C3                           mov bx,ax                          ;BX=代表光标位置的16位数
    72                                  
    73 00000029 80F90D                           cmp cl,0x0d                        ;回车符？
    74 0000002C 750E                             jnz .put_0a
    75 0000002E 6689D8                           mov ax,bx
    76 00000031 B350                             mov bl,80
    77 00000033 F6F3                             div bl
    78 00000035 F6E3                             mul bl
    79 00000037 6689C3                           mov bx,ax
    80 0000003A EB65                             jmp .set_cursor
    81                                  
    82                                    .put_0a:
    83 0000003C 80F90A                           cmp cl,0x0a                        ;换行符？
    84 0000003F 7506                             jnz .put_other
    85 00000041 6683C350                         add bx,80
    86 00000045 EB15                             jmp .roll_screen
    87                                  
    88                                    .put_other:                               ;正常显示字符
    89 00000047 06                               push es
    90 00000048 B820000000                       mov eax,video_ram_seg_sel          ;0xb8000段的选择子
    91 0000004D 8EC0                             mov es,eax
    92 0000004F 66D1E3                           shl bx,1
    93 00000052 2667880F                         mov [es:bx],cl
    94 00000056 07                               pop es
    95                                  
    96                                           ;以下将光标位置推进一个字符
    97 00000057 66D1EB                           shr bx,1
    98 0000005A 6643                             inc bx
    99                                  
   100                                    .roll_screen:
   101 0000005C 6681FBD007                       cmp bx,2000                        ;光标超出屏幕？滚屏
   102 00000061 7C3E                             jl .set_cursor
   103                                  
   104 00000063 6653                             push bx                            ;为了修改原书程序的逻辑问题，新增
   105 00000065 1E                               push ds
   106 00000066 06                               push es
   107 00000067 B820000000                       mov eax,video_ram_seg_sel
   108 0000006C 8ED8                             mov ds,eax
   109 0000006E 8EC0                             mov es,eax
   110 00000070 FC                               cld
   111 00000071 BEA0000000                       mov esi,0xa0                       ;小心！32位模式下movsb/w/d
   112 00000076 BF00000000                       mov edi,0x00                       ;使用的是esi/edi/ecx
   113 0000007B B980070000                       mov ecx,1920
   114 00000080 F366A5                           rep movsw
   115 00000083 66BB000F                         mov bx,3840                        ;清除屏幕最底一行
   116 00000087 B950000000                       mov ecx,80                         ;32位程序应该使用ECX
   117                                    .cls:
   118 0000008C 266667C7072007                   mov word[es:bx],0x0720
   119 00000093 6683C302                         add bx,2
   120 00000097 E2F3                             loop .cls
   121                                  
   122 00000099 07                               pop es
   123 0000009A 1F                               pop ds
   124                                  
   125                                           ;mov bx,1920                       ;为了修改原书程序的逻辑问题，删除
   126 0000009B 665B                             pop bx                             ;为了修改原书程序的逻辑问题，新增
   127 0000009D 6683EB50                         sub bx,80                          ;为了修改原书程序的逻辑问题，新增
   128                                  
   129                                    .set_cursor:
   130 000000A1 66BAD403                         mov dx,0x3d4
   131 000000A5 B00E                             mov al,0x0e
   132 000000A7 EE                               out dx,al
   133 000000A8 6642                             inc dx                             ;0x3d5
   134 000000AA 88F8                             mov al,bh
   135 000000AC EE                               out dx,al
   136 000000AD 664A                             dec dx                             ;0x3d4
   137 000000AF B00F                             mov al,0x0f
   138 000000B1 EE                               out dx,al
   139 000000B2 6642                             inc dx                             ;0x3d5
   140 000000B4 88D8                             mov al,bl
   141 000000B6 EE                               out dx,al
   142                                  
   143 000000B7 61                               popad
   144 000000B8 C3                               ret
   145                                  
   146                                  ;-------------------------------------------------------------------------------
   147                                  ;此例程用于说明如何通过请求特权级RPL解决因请求者身份与CPL不同而带来的安全问题
   148                                  ;read_hard_disk_with_gate:                  ;从硬盘读取一个逻辑扇区
   149                                                                              ;输入：PUSH 逻辑扇区号
   150                                                                              ;      PUSH 目标缓冲区所在段的选择子
   151                                                                              ;      PUSH 目标缓冲区在段内的偏移量
   152                                                                              ;返回：无
   153                                           ;push eax
   154                                           ;push ebx
   155                                           ;push ecx
   156                                  
   157                                           ;mov ax,[esp+0x10]                  ;获取调用者的CS
   158                                           ;arpl [esp+0x18],ax                 ;将数据段选择子调整到真实的请求特权级别
   159                                           ;mov ds,[esp+0x18]                  ;用真实的段选择子加载段寄存器DS
   160                                  
   161                                           ;mov eax,[esp+0x1c]                 ;从栈中取得逻辑扇区号
   162                                           ;mov ebx,[esp+0x14]                 ;从栈中取得缓冲区在段内的偏移量
   163                                  
   164                                           ;此部分的功能是读硬盘，并传送到缓冲区，予以省略。
   165                                  
   166                                           ;retf 12
   167                                  
   168                                  ;-------------------------------------------------------------------------------
   169                                  read_hard_disk_0:                           ;从硬盘读取一个逻辑扇区
   170                                                                              ;EAX=逻辑扇区号
   171                                                                              ;DS:EBX=目标缓冲区地址
   172                                                                              ;返回：EBX=EBX+512
   173 000000B9 50                               push eax 
   174 000000BA 51                               push ecx
   175 000000BB 52                               push edx
   176                                        
   177 000000BC 50                               push eax
   178                                           
   179 000000BD 66BAF201                         mov dx,0x1f2
   180 000000C1 B001                             mov al,1
   181 000000C3 EE                               out dx,al                          ;读取的扇区数
   182                                  
   183 000000C4 6642                             inc dx                             ;0x1f3
   184 000000C6 58                               pop eax
   185 000000C7 EE                               out dx,al                          ;LBA地址7~0
   186                                  
   187 000000C8 6642                             inc dx                             ;0x1f4
   188 000000CA B108                             mov cl,8
   189 000000CC D3E8                             shr eax,cl
   190 000000CE EE                               out dx,al                          ;LBA地址15~8
   191                                  
   192 000000CF 6642                             inc dx                             ;0x1f5
   193 000000D1 D3E8                             shr eax,cl
   194 000000D3 EE                               out dx,al                          ;LBA地址23~16
   195                                  
   196 000000D4 6642                             inc dx                             ;0x1f6
   197 000000D6 D3E8                             shr eax,cl
   198 000000D8 0CE0                             or al,0xe0                         ;第一硬盘  LBA地址27~24
   199 000000DA EE                               out dx,al
   200                                  
   201 000000DB 6642                             inc dx                             ;0x1f7
   202 000000DD B020                             mov al,0x20                        ;读命令
   203 000000DF EE                               out dx,al
   204                                  
   205                                    .waits:
   206 000000E0 EC                               in al,dx
   207 000000E1 2488                             and al,0x88
   208 000000E3 3C08                             cmp al,0x08
   209 000000E5 75F9                             jnz .waits                         ;不忙，且硬盘已准备好数据传输 
   210                                  
   211 000000E7 B900010000                       mov ecx,256                        ;总共要读取的字数
   212 000000EC 66BAF001                         mov dx,0x1f0
   213                                    .readw:
   214 000000F0 66ED                             in ax,dx
   215 000000F2 668903                           mov [ebx],ax
   216 000000F5 83C302                           add ebx,2
   217 000000F8 E2F6                             loop .readw
   218                                  
   219 000000FA 5A                               pop edx
   220 000000FB 59                               pop ecx
   221 000000FC 58                               pop eax
   222                                        
   223 000000FD CB                               retf                               ;段间返回 
   224                                  
   225                                  ;-------------------------------------------------------------------------------
   226                                  ;汇编语言程序是极难一次成功，而且调试非常困难。这个例程可以提供帮助 
   227                                  put_hex_dword:                              ;在当前光标处以十六进制形式显示
   228                                                                              ;一个双字并推进光标 
   229                                                                              ;输入：EDX=要转换并显示的数字
   230                                                                              ;输出：无
   231 000000FE 60                               pushad
   232 000000FF 1E                               push ds
   233                                        
   234 00000100 66B83000                         mov ax,core_data_seg_sel           ;切换到核心数据段 
   235 00000104 8ED8                             mov ds,ax
   236                                        
   237 00000106 BB[2B050000]                     mov ebx,bin_hex                    ;指向核心数据段内的转换表
   238 0000010B B908000000                       mov ecx,8
   239                                    .xlt:    
   240 00000110 C1C204                           rol edx,4
   241 00000113 89D0                             mov eax,edx
   242 00000115 83E00F                           and eax,0x0000000f
   243 00000118 D7                               xlat
   244                                        
   245 00000119 51                               push ecx
   246 0000011A 88C1                             mov cl,al                           
   247 0000011C E8F0FEFFFF                       call put_char
   248 00000121 59                               pop ecx
   249                                         
   250 00000122 E2EC                             loop .xlt
   251                                        
   252 00000124 1F                               pop ds
   253 00000125 61                               popad
   254 00000126 CB                               retf
   255                                        
   256                                  ;-------------------------------------------------------------------------------
   257                                  allocate_memory:                            ;分配内存
   258                                                                              ;输入：ECX=希望分配的字节数
   259                                                                              ;输出：ECX=起始线性地址 
   260 00000127 1E                               push ds
   261 00000128 50                               push eax
   262 00000129 53                               push ebx
   263                                        
   264 0000012A B830000000                       mov eax,core_data_seg_sel
   265 0000012F 8ED8                             mov ds,eax
   266                                        
   267 00000131 A1[06000000]                     mov eax,[ram_alloc]
   268 00000136 01C8                             add eax,ecx                        ;下一次分配时的起始地址
   269                                        
   270                                           ;这里应当有检测可用内存数量的指令
   271                                            
   272 00000138 8B0D[06000000]                   mov ecx,[ram_alloc]                ;返回分配的起始地址
   273                                  
   274 0000013E 89C3                             mov ebx,eax
   275 00000140 83E3FC                           and ebx,0xfffffffc
   276 00000143 83C304                           add ebx,4                          ;强制对齐 
   277 00000146 A903000000                       test eax,0x00000003                ;下次分配的起始地址最好是4字节对齐
   278 0000014B 0F45C3                           cmovnz eax,ebx                     ;如果没有对齐，则强制对齐 
   279 0000014E A3[06000000]                     mov [ram_alloc],eax                ;下次从该地址分配内存
   280                                                                              ;cmovcc指令可以避免控制转移 
   281 00000153 5B                               pop ebx
   282 00000154 58                               pop eax
   283 00000155 1F                               pop ds
   284                                  
   285 00000156 CB                               retf
   286                                  
   287                                  ;-------------------------------------------------------------------------------
   288                                  set_up_gdt_descriptor:                      ;在GDT内安装一个新的描述符
   289                                                                              ;输入：EDX:EAX=描述符 
   290                                                                              ;输出：CX=描述符的选择子
   291 00000157 50                               push eax
   292 00000158 53                               push ebx
   293 00000159 52                               push edx
   294                                  
   295 0000015A 1E                               push ds
   296 0000015B 06                               push es
   297                                  
   298 0000015C BB30000000                       mov ebx,core_data_seg_sel          ;切换到核心数据段
   299 00000161 8EDB                             mov ds,ebx
   300                                  
   301 00000163 0F0105[00000000]                 sgdt [pgdt]                        ;以便开始处理GDT
   302                                  
   303 0000016A BB08000000                       mov ebx,mem_0_4_gb_seg_sel
   304 0000016F 8EC3                             mov es,ebx
   305                                  
   306 00000171 0FB71D[00000000]                 movzx ebx,word [pgdt]              ;GDT界限
   307 00000178 6643                             inc bx                             ;GDT总字节数，也是下一个描述符偏移
   308 0000017A 031D[02000000]                   add ebx,[pgdt+2]                   ;下一个描述符的线性地址
   309                                  
   310 00000180 268903                           mov [es:ebx],eax
   311 00000183 26895304                         mov [es:ebx+4],edx
   312                                  
   313 00000187 668305[00000000]08               add word [pgdt],8                  ;增加一个描述符的大小
   314                                  
   315 0000018F 0F0115[00000000]                 lgdt [pgdt]                        ;对GDT的更改生效
   316                                  
   317 00000196 66A1[00000000]                   mov ax,[pgdt]                      ;得到GDT界限值
   318 0000019C 6631D2                           xor dx,dx
   319 0000019F 66BB0800                         mov bx,8
   320 000001A3 66F7F3                           div bx                             ;除以8，去掉余数
   321 000001A6 6689C1                           mov cx,ax
   322 000001A9 66C1E103                         shl cx,3                           ;将索引号移到正确位置
   323                                  
   324 000001AD 07                               pop es
   325 000001AE 1F                               pop ds
   326                                  
   327 000001AF 5A                               pop edx
   328 000001B0 5B                               pop ebx
   329 000001B1 58                               pop eax
   330                                  
   331 000001B2 CB                               retf
   332                                  
   333                                  ;-------------------------------------------------------------------------------
   334                                  make_seg_descriptor:                        ;构造存储器和系统的段描述符
   335                                                                              ;输入：EAX=线性基地址
   336                                                                              ;      EBX=段界限
   337                                                                              ;      ECX=属性。各属性位都在原始
   338                                                                              ;          位置，无关的位清零 
   339                                                                              ;返回：EDX:EAX=描述符
   340 000001B3 89C2                             mov edx,eax
   341 000001B5 C1E010                           shl eax,16
   342 000001B8 6609D8                           or ax,bx                           ;描述符前32位(EAX)构造完毕
   343                                  
   344 000001BB 81E20000FFFF                     and edx,0xffff0000                 ;清除基地址中无关的位
   345 000001C1 C1C208                           rol edx,8
   346 000001C4 0FCA                             bswap edx                          ;装配基址的31~24和23~16  (80486+)
   347                                  
   348 000001C6 6631DB                           xor bx,bx
   349 000001C9 09DA                             or edx,ebx                         ;装配段界限的高4位
   350                                  
   351 000001CB 09CA                             or edx,ecx                         ;装配属性
   352                                  
   353 000001CD CB                               retf
   354                                  
   355                                  ;-------------------------------------------------------------------------------
   356                                  make_gate_descriptor:                       ;构造门的描述符（调用门等）
   357                                                                              ;输入：EAX=门代码在段内偏移地址
   358                                                                              ;       BX=门代码所在段的选择子
   359                                                                              ;       CX=段类型及属性等（各属
   360                                                                              ;          性位都在原始位置）
   361                                                                              ;返回：EDX:EAX=完整的描述符
   362 000001CE 53                               push ebx
   363 000001CF 51                               push ecx
   364                                  
   365 000001D0 89C2                             mov edx,eax
   366 000001D2 6689CA                           mov dx,cx                          ;组装调用门的高双字部分
   367                                  
   368 000001D5 25FFFF0000                       and eax,0x0000ffff                 ;得到偏移地址低16位
   369 000001DA C1E310                           shl ebx,16
   370 000001DD 09D8                             or eax,ebx                         ;组装段选择子部分
   371                                  
   372 000001DF 59                               pop ecx
   373 000001E0 5B                               pop ebx
   374                                  
   375 000001E1 CB                               retf
   376                                  
   377                                  sys_routine_end:
   378                                  
   379                                  ;===============================================================================
   380                                  SECTION core_data vstart=0                  ;系统核心的数据段 
   381                                  ;------------------------------------------------------------------------------- 
   382 00000000 0000                             pgdt             dw  0             ;用于设置和修改GDT 
   383 00000002 00000000                                          dd  0
   384                                  
   385 00000006 00001000                         ram_alloc        dd  0x00100000    ;下次分配内存时的起始地址
   386                                  
   387                                           ;符号地址检索表
   388                                           salt:
   389 0000000A 405072696E74537472-              salt_1           db  '@PrintString'
   389 00000013 696E67             
   390 00000016 00<rep F4h>                                  times 256-($-salt_1) db 0
   391 0000010A [00000000]                                        dd  put_string
   392 0000010E 2800                                              dw  sys_routine_seg_sel
   393                                  
   394 00000110 40526561644469736B-              salt_2           db  '@ReadDiskData'
   394 00000119 44617461           
   395 0000011D 00<rep F3h>                                  times 256-($-salt_2) db 0
   396 00000210 [B9000000]                                        dd  read_hard_disk_0
   397 00000214 2800                                              dw  sys_routine_seg_sel
   398                                  
   399 00000216 405072696E7444776F-              salt_3           db  '@PrintDwordAsHexString'
   399 0000021F 726441734865785374-
   399 00000228 72696E67           
   400 0000022C 00<rep EAh>                                  times 256-($-salt_3) db 0
   401 00000316 [FE000000]                                        dd  put_hex_dword
   402 0000031A 2800                                              dw  sys_routine_seg_sel
   403                                  
   404 0000031C 405465726D696E6174-              salt_4           db  '@TerminateProgram'
   404 00000325 6550726F6772616D   
   405 0000032D 00<rep EFh>                                  times 256-($-salt_4) db 0
   406 0000041C [8C040000]                                        dd  return_point
   407 00000420 3800                                              dw  core_code_seg_sel
   408                                  
   409                                           salt_item_len   equ $-salt_4
   410                                           salt_items      equ ($-salt)/salt_item_len
   411                                  
   412 00000422 2020496620796F7520-              message_1        db  '  If you seen this message,that means we '
   412 0000042B 7365656E2074686973-
   412 00000434 206D6573736167652C-
   412 0000043D 74686174206D65616E-
   412 00000446 7320776520         
   413 0000044B 617265206E6F772069-                               db  'are now in protect mode,and the system '
   413 00000454 6E2070726F74656374-
   413 0000045D 206D6F64652C616E64-
   413 00000466 207468652073797374-
   413 0000046F 656D20             
   414 00000472 636F7265206973206C-                               db  'core is loaded,and the video display '
   414 0000047B 6F616465642C616E64-
   414 00000484 207468652076696465-
   414 0000048D 6F20646973706C6179-
   414 00000496 20                 
   415 00000497 726F7574696E652077-                               db  'routine works perfectly.',0x0d,0x0a,0
   415 000004A0 6F726B732070657266-
   415 000004A9 6563746C792E0D0A00 
   416                                  
   417 000004B2 202053797374656D20-              message_2        db  '  System wide CALL-GATE mounted.',0x0d,0x0a,0
   417 000004BB 776964652043414C4C-
   417 000004C4 2D47415445206D6F75-
   417 000004CD 6E7465642E0D0A00   
   418                                  
   419 000004D5 0D0A20204C6F616469-              message_3        db  0x0d,0x0a,'  Loading user program...',0
   419 000004DE 6E6720757365722070-
   419 000004E7 726F6772616D2E2E2E-
   419 000004F0 00                 
   420                                           
   421 000004F1 446F6E652E0D0A00                 do_status        db  'Done.',0x0d,0x0a,0
   422                                           
   423 000004F9 0D0A0D0A0D0A                     message_6        db  0x0d,0x0a,0x0d,0x0a,0x0d,0x0a
   424 000004FF 202055736572207072-                               db  '  User program terminated,control returned.',0
   424 00000508 6F6772616D20746572-
   424 00000511 6D696E617465642C63-
   424 0000051A 6F6E74726F6C207265-
   424 00000523 7475726E65642E00   
   425                                  
   426 0000052B 303132333435363738-              bin_hex          db '0123456789ABCDEF'
   426 00000534 39414243444546     
   427                                                                              ;put_hex_dword子过程用的查找表 
   428                                  
   429 0000053B 00<rep 800h>                     core_buf   times 2048 db 0         ;内核用的缓冲区
   430                                  
   431 00000D3B 00000000                         esp_pointer      dd 0              ;内核用来临时保存自己的栈指针     
   432                                  
   433 00000D3F 0D0A202000                       cpu_brnd0        db 0x0d,0x0a,'  ',0
   434 00000D44 00<rep 34h>                      cpu_brand  times 52 db 0
   435 00000D78 0D0A0D0A00                       cpu_brnd1        db 0x0d,0x0a,0x0d,0x0a,0
   436                                  
   437                                           ;任务控制块链
   438 00000D7D 00000000                         tcb_chain        dd  0
   439                                  
   440                                  core_data_end:
   441                                                 
   442                                  ;===============================================================================
   443                                  SECTION core_code vstart=0
   444                                  ;-------------------------------------------------------------------------------
   445                                  fill_descriptor_in_ldt:                     ;在LDT内安装一个新的描述符
   446                                                                              ;输入：EDX:EAX=描述符
   447                                                                              ;          EBX=TCB基地址
   448                                                                              ;输出：CX=描述符的选择子
   449 00000000 50                               push eax
   450 00000001 52                               push edx
   451 00000002 57                               push edi
   452 00000003 1E                               push ds
   453                                  
   454 00000004 B908000000                       mov ecx,mem_0_4_gb_seg_sel
   455 00000009 8ED9                             mov ds,ecx
   456                                  
   457 0000000B 8B7B0C                           mov edi,[ebx+0x0c]                 ;获得LDT基地址
   458                                           
   459 0000000E 31C9                             xor ecx,ecx
   460 00000010 668B4B0A                         mov cx,[ebx+0x0a]                  ;获得LDT界限
   461 00000014 6641                             inc cx                             ;LDT的总字节数，即新描述符偏移地址
   462                                           
   463 00000016 89040F                           mov [edi+ecx+0x00],eax
   464 00000019 89540F04                         mov [edi+ecx+0x04],edx             ;安装描述符
   465                                  
   466 0000001D 6683C108                         add cx,8                           
   467 00000021 6649                             dec cx                             ;得到新的LDT界限值 
   468                                  
   469 00000023 66894B0A                         mov [ebx+0x0a],cx                  ;更新LDT界限值到TCB
   470                                  
   471 00000027 6689C8                           mov ax,cx
   472 0000002A 6631D2                           xor dx,dx
   473 0000002D 66B90800                         mov cx,8
   474 00000031 66F7F1                           div cx
   475                                           
   476 00000034 6689C1                           mov cx,ax
   477 00000037 66C1E103                         shl cx,3                           ;左移3位，并且
   478 0000003B 6683C904                         or cx,0000_0000_0000_0100B         ;使TI位=1，指向LDT，最后使RPL=00 
   479                                  
   480 0000003F 1F                               pop ds
   481 00000040 5F                               pop edi
   482 00000041 5A                               pop edx
   483 00000042 58                               pop eax
   484                                       
   485 00000043 C3                               ret
   486                                        
   487                                  ;------------------------------------------------------------------------------- 
   488                                  load_relocate_program:                      ;加载并重定位用户程序
   489                                                                              ;输入: PUSH 逻辑扇区号
   490                                                                              ;      PUSH 任务控制块基地址
   491                                                                              ;输出：无 
   492 00000044 60                               pushad
   493                                        
   494 00000045 1E                               push ds
   495 00000046 06                               push es
   496                                        
   497 00000047 89E5                             mov ebp,esp                        ;为访问通过堆栈传递的参数做准备
   498                                        
   499 00000049 B908000000                       mov ecx,mem_0_4_gb_seg_sel
   500 0000004E 8EC1                             mov es,ecx
   501                                        
   502 00000050 8B752C                           mov esi,[ebp+11*4]                 ;从堆栈中取得TCB的基地址
   503                                  
   504                                           ;以下申请创建LDT所需要的内存
   505 00000053 B9A0000000                       mov ecx,160                        ;允许安装20个LDT描述符
   506 00000058 9A[27010000]2800                 call sys_routine_seg_sel:allocate_memory
   507 0000005F 26894E0C                         mov [es:esi+0x0c],ecx              ;登记LDT基地址到TCB中
   508 00000063 2666C7460AFFFF                   mov word [es:esi+0x0a],0xffff      ;登记LDT初始的界限到TCB中 
   509                                  
   510                                           ;以下开始加载用户程序 
   511 0000006A B830000000                       mov eax,core_data_seg_sel
   512 0000006F 8ED8                             mov ds,eax                         ;切换DS到内核数据段
   513                                         
   514 00000071 8B4530                           mov eax,[ebp+12*4]                 ;从堆栈中取出用户程序起始扇区号 
   515 00000074 BB[3B050000]                     mov ebx,core_buf                   ;读取程序头部数据     
   516 00000079 9A[B9000000]2800                 call sys_routine_seg_sel:read_hard_disk_0
   517                                  
   518                                           ;以下判断整个程序有多大
   519 00000080 A1[3B050000]                     mov eax,[core_buf]                 ;程序尺寸
   520 00000085 89C3                             mov ebx,eax
   521 00000087 81E300FEFFFF                     and ebx,0xfffffe00                 ;使之512字节对齐（能被512整除的数低 
   522 0000008D 81C300020000                     add ebx,512                        ;9位都为0 
   523 00000093 A9FF010000                       test eax,0x000001ff                ;程序的大小正好是512的倍数吗? 
   524 00000098 0F45C3                           cmovnz eax,ebx                     ;不是。使用凑整的结果
   525                                        
   526 0000009B 89C1                             mov ecx,eax                        ;实际需要申请的内存数量
   527 0000009D 9A[27010000]2800                 call sys_routine_seg_sel:allocate_memory
   528 000000A4 26894E06                         mov [es:esi+0x06],ecx              ;登记程序加载基地址到TCB中
   529                                        
   530 000000A8 89CB                             mov ebx,ecx                        ;ebx -> 申请到的内存首地址
   531 000000AA 31D2                             xor edx,edx
   532 000000AC B900020000                       mov ecx,512
   533 000000B1 F7F1                             div ecx
   534 000000B3 89C1                             mov ecx,eax                        ;总扇区数 
   535                                        
   536 000000B5 B808000000                       mov eax,mem_0_4_gb_seg_sel         ;切换DS到0-4GB的段
   537 000000BA 8ED8                             mov ds,eax
   538                                  
   539 000000BC 8B4530                           mov eax,[ebp+12*4]                 ;起始扇区号 
   540                                    .b1:
   541 000000BF 9A[B9000000]2800                 call sys_routine_seg_sel:read_hard_disk_0
   542 000000C6 40                               inc eax
   543 000000C7 E2F6                             loop .b1                           ;循环读，直到读完整个用户程序
   544                                  
   545 000000C9 268B7E06                         mov edi,[es:esi+0x06]              ;获得程序加载基地址
   546                                  
   547                                           ;建立程序头部段描述符
   548 000000CD 89F8                             mov eax,edi                        ;程序头部起始线性地址
   549 000000CF 8B5F04                           mov ebx,[edi+0x04]                 ;段长度
   550 000000D2 4B                               dec ebx                            ;段界限
   551 000000D3 B900F24000                       mov ecx,0x0040f200                 ;字节粒度的数据段描述符，特权级3
   552 000000D8 9A[B3010000]2800                 call sys_routine_seg_sel:make_seg_descriptor
   553                                        
   554                                           ;安装头部段描述符到LDT中 
   555 000000DF 89F3                             mov ebx,esi                        ;TCB的基地址
   556 000000E1 E81AFFFFFF                       call fill_descriptor_in_ldt
   557                                  
   558 000000E6 6683C903                         or cx,0000_0000_0000_0011B         ;设置选择子的特权级为3
   559 000000EA 2666894E44                       mov [es:esi+0x44],cx               ;登记程序头部段选择子到TCB
   560 000000EF 66894F04                         mov [edi+0x04],cx                  ;和头部内 
   561                                        
   562                                           ;建立程序代码段描述符
   563 000000F3 89F8                             mov eax,edi
   564 000000F5 03470C                           add eax,[edi+0x0c]                 ;代码起始线性地址
   565 000000F8 8B5F10                           mov ebx,[edi+0x10]                 ;段长度
   566 000000FB 4B                               dec ebx                            ;段界限
   567 000000FC B900F84000                       mov ecx,0x0040f800                 ;字节粒度的代码段描述符，特权级3
   568 00000101 9A[B3010000]2800                 call sys_routine_seg_sel:make_seg_descriptor
   569 00000108 89F3                             mov ebx,esi                        ;TCB的基地址
   570 0000010A E8F1FEFFFF                       call fill_descriptor_in_ldt
   571 0000010F 6683C903                         or cx,0000_0000_0000_0011B         ;设置选择子的特权级为3
   572 00000113 66894F0C                         mov [edi+0x0c],cx                  ;登记代码段选择子到头部
   573                                  
   574                                           ;建立程序数据段描述符
   575 00000117 89F8                             mov eax,edi
   576 00000119 034714                           add eax,[edi+0x14]                 ;数据段起始线性地址
   577 0000011C 8B5F18                           mov ebx,[edi+0x18]                 ;段长度
   578 0000011F 4B                               dec ebx                            ;段界限 
   579 00000120 B900F24000                       mov ecx,0x0040f200                 ;字节粒度的数据段描述符，特权级3
   580 00000125 9A[B3010000]2800                 call sys_routine_seg_sel:make_seg_descriptor
   581 0000012C 89F3                             mov ebx,esi                        ;TCB的基地址
   582 0000012E E8CDFEFFFF                       call fill_descriptor_in_ldt
   583 00000133 6683C903                         or cx,0000_0000_0000_0011B         ;设置选择子的特权级为3
   584 00000137 66894F14                         mov [edi+0x14],cx                  ;登记数据段选择子到头部
   585                                  
   586                                           ;建立程序堆栈段描述符
   587 0000013B 89F8                             mov eax,edi
   588 0000013D 03471C                           add eax,[edi+0x1c]                 ;数据段起始线性地址
   589 00000140 8B5F20                           mov ebx,[edi+0x20]                 ;段长度
   590 00000143 4B                               dec ebx                            ;段界限
   591 00000144 B900F24000                       mov ecx,0x0040f200                 ;字节粒度的堆栈段描述符，特权级3
   592 00000149 9A[B3010000]2800                 call sys_routine_seg_sel:make_seg_descriptor
   593 00000150 89F3                             mov ebx,esi                        ;TCB的基地址
   594 00000152 E8A9FEFFFF                       call fill_descriptor_in_ldt
   595 00000157 6683C903                         or cx,0000_0000_0000_0011B         ;设置选择子的特权级为3
   596 0000015B 66894F1C                         mov [edi+0x1c],cx                  ;登记堆栈段选择子到头部
   597                                  
   598                                           ;重定位SALT 
   599 0000015F B808000000                       mov eax,mem_0_4_gb_seg_sel         ;这里和前一章不同，头部段描述符
   600 00000164 8EC0                             mov es,eax                         ;已安装，但还没有生效，故只能通
   601                                                                              ;过4GB段访问用户程序头部          
   602 00000166 B830000000                       mov eax,core_data_seg_sel
   603 0000016B 8ED8                             mov ds,eax
   604                                        
   605 0000016D FC                               cld
   606                                  
   607 0000016E 268B4F24                         mov ecx,[es:edi+0x24]              ;U-SALT条目数(通过访问4GB段取得) 
   608 00000172 83C728                           add edi,0x28                       ;U-SALT在4GB段内的偏移 
   609                                    .b2: 
   610 00000175 51                               push ecx
   611 00000176 57                               push edi
   612                                        
   613 00000177 B904000000                       mov ecx,salt_items
   614 0000017C BE[0A000000]                     mov esi,salt
   615                                    .b3:
   616 00000181 57                               push edi
   617 00000182 56                               push esi
   618 00000183 51                               push ecx
   619                                  
   620 00000184 B940000000                       mov ecx,64                         ;检索表中，每条目的比较次数 
   621 00000189 F3A7                             repe cmpsd                         ;每次比较4字节 
   622 0000018B 7519                             jnz .b4
   623 0000018D 8B06                             mov eax,[esi]                      ;若匹配，则esi恰好指向其后的地址
   624 0000018F 26898700FFFFFF                   mov [es:edi-256],eax               ;将字符串改写成偏移地址 
   625 00000196 668B4604                         mov ax,[esi+4]
   626 0000019A 6683C803                         or ax,0000000000000011B            ;以用户程序自己的特权级使用调用门
   627                                                                              ;故RPL=3
   628 0000019E 2666898704FFFFFF                 mov [es:edi-252],ax                ;回填段选择子
   629                                    .b4:
   630                                        
   631 000001A6 59                               pop ecx
   632 000001A7 5E                               pop esi
   633 000001A8 81C606010000                     add esi,salt_item_len
   634 000001AE 5F                               pop edi                            ;从头比较 
   635 000001AF E2D0                             loop .b3
   636                                        
   637 000001B1 5F                               pop edi
   638 000001B2 81C700010000                     add edi,256
   639 000001B8 59                               pop ecx
   640 000001B9 E2BA                             loop .b2
   641                                  
   642 000001BB 8B752C                           mov esi,[ebp+11*4]                 ;从堆栈中取得TCB的基地址
   643                                  
   644                                           ;创建0特权级栈
   645 000001BE B900000000                       mov ecx,0                          ;以4KB为单位的栈段界限值
   646 000001C3 26894E1A                         mov [es:esi+0x1a],ecx              ;登记0特权级栈界限到TCB
   647 000001C7 41                               inc ecx
   648 000001C8 C1E10C                           shl ecx,12                         ;乘以4096，得到段大小
   649 000001CB 51                               push ecx
   650 000001CC 9A[27010000]2800                 call sys_routine_seg_sel:allocate_memory
   651 000001D3 26894E1E                         mov [es:esi+0x1e],ecx              ;登记0特权级栈基地址到TCB
   652 000001D7 89C8                             mov eax,ecx
   653 000001D9 268B5E1A                         mov ebx,[es:esi+0x1a]              ;段长度（界限）
   654 000001DD B90092C000                       mov ecx,0x00c09200                 ;4KB粒度，读写，特权级0
   655 000001E2 9A[B3010000]2800                 call sys_routine_seg_sel:make_seg_descriptor
   656 000001E9 89F3                             mov ebx,esi                        ;TCB的基地址
   657 000001EB E810FEFFFF                       call fill_descriptor_in_ldt
   658                                           ;or cx,0000_0000_0000_0000          ;设置选择子的特权级为0
   659 000001F0 2666894E22                       mov [es:esi+0x22],cx               ;登记0特权级堆栈选择子到TCB
   660 000001F5 268F4624                         pop dword [es:esi+0x24]            ;登记0特权级堆栈初始ESP到TCB
   661                                  
   662                                           ;创建1特权级堆栈
   663 000001F9 B900000000                       mov ecx,0
   664 000001FE 26894E28                         mov [es:esi+0x28],ecx              ;登记1特权级堆栈尺寸到TCB
   665 00000202 41                               inc ecx
   666 00000203 C1E10C                           shl ecx,12                         ;乘以4096，得到段大小
   667 00000206 51                               push ecx
   668 00000207 9A[27010000]2800                 call sys_routine_seg_sel:allocate_memory
   669 0000020E 26894E2C                         mov [es:esi+0x2c],ecx              ;登记1特权级堆栈基地址到TCB
   670 00000212 89C8                             mov eax,ecx
   671 00000214 268B5E28                         mov ebx,[es:esi+0x28]              ;段长度（界限）
   672 00000218 B900B2C000                       mov ecx,0x00c0b200                 ;4KB粒度，读写，特权级1
   673 0000021D 9A[B3010000]2800                 call sys_routine_seg_sel:make_seg_descriptor
   674 00000224 89F3                             mov ebx,esi                        ;TCB的基地址
   675 00000226 E8D5FDFFFF                       call fill_descriptor_in_ldt
   676 0000022B 6683C901                         or cx,0000_0000_0000_0001          ;设置选择子的特权级为1
   677 0000022F 2666894E30                       mov [es:esi+0x30],cx               ;登记1特权级堆栈选择子到TCB
   678 00000234 268F4632                         pop dword [es:esi+0x32]            ;登记1特权级堆栈初始ESP到TCB
   679                                  
   680                                           ;创建2特权级堆栈
   681 00000238 B900000000                       mov ecx,0
   682 0000023D 26894E36                         mov [es:esi+0x36],ecx              ;登记2特权级堆栈尺寸到TCB
   683 00000241 41                               inc ecx
   684 00000242 C1E10C                           shl ecx,12                         ;乘以4096，得到段大小
   685 00000245 51                               push ecx
   686 00000246 9A[27010000]2800                 call sys_routine_seg_sel:allocate_memory
   687 0000024D 26894E3A                         mov [es:esi+0x3a],ecx              ;登记2特权级堆栈基地址到TCB
   688 00000251 89C8                             mov eax,ecx
   689 00000253 268B5E36                         mov ebx,[es:esi+0x36]              ;段长度（界限）
   690 00000257 B900D2C000                       mov ecx,0x00c0d200                 ;4KB粒度，读写，特权级2
   691 0000025C 9A[B3010000]2800                 call sys_routine_seg_sel:make_seg_descriptor
   692 00000263 89F3                             mov ebx,esi                        ;TCB的基地址
   693 00000265 E896FDFFFF                       call fill_descriptor_in_ldt
   694 0000026A 6683C90A                         or cx,0000_0000_0000_0010          ;设置选择子的特权级为2
   695 0000026E 2666894E3E                       mov [es:esi+0x3e],cx               ;登记2特权级堆栈选择子到TCB
   696 00000273 268F4640                         pop dword [es:esi+0x40]            ;登记2特权级堆栈初始ESP到TCB
   697                                  
   698                                           ;在GDT中登记LDT描述符
   699 00000277 268B460C                         mov eax,[es:esi+0x0c]              ;LDT的起始线性地址
   700 0000027B 260FB75E0A                       movzx ebx,word [es:esi+0x0a]       ;LDT段界限
   701 00000280 B900820000                       mov ecx,0x00008200                 ;LDT描述符，特权级0
   702 00000285 9A[B3010000]2800                 call sys_routine_seg_sel:make_seg_descriptor
   703 0000028C 9A[57010000]2800                 call sys_routine_seg_sel:set_up_gdt_descriptor
   704 00000293 2666894E10                       mov [es:esi+0x10],cx               ;登记LDT选择子到TCB中
   705                                         
   706                                           ;创建用户程序的TSS
   707 00000298 B968000000                       mov ecx,104                        ;tss的基本尺寸
   708 0000029D 2666894E12                       mov [es:esi+0x12],cx              
   709 000002A2 2666FF4E12                       dec word [es:esi+0x12]             ;登记TSS界限值到TCB 
   710 000002A7 9A[27010000]2800                 call sys_routine_seg_sel:allocate_memory
   711 000002AE 26894E14                         mov [es:esi+0x14],ecx              ;登记TSS基地址到TCB
   712                                        
   713                                           ;登记基本的TSS表格内容
   714 000002B2 268B5624                         mov edx,[es:esi+0x24]              ;登记0特权级栈初始ESP
   715 000002B6 26895104                         mov [es:ecx+4],edx                 ;到TSS中
   716                                  
   717 000002BA 26668B5622                       mov dx,[es:esi+0x22]               ;登记0特权级栈段选择子
   718 000002BF 2666895108                       mov [es:ecx+8],dx                  ;到TSS中
   719                                  
   720 000002C4 268B5632                         mov edx,[es:esi+0x32]              ;登记1特权级栈初始ESP
   721 000002C8 2689510C                         mov [es:ecx+12],edx                ;到TSS中
   722                                  
   723 000002CC 26668B5630                       mov dx,[es:esi+0x30]               ;登记1特权级栈段选择子
   724 000002D1 2666895110                       mov [es:ecx+16],dx                 ;到TSS中
   725                                  
   726 000002D6 268B5640                         mov edx,[es:esi+0x40]              ;登记2特权级栈初始ESP
   727 000002DA 26895114                         mov [es:ecx+20],edx                ;到TSS中
   728                                  
   729 000002DE 26668B563E                       mov dx,[es:esi+0x3e]               ;登记2特权级栈段选择子
   730 000002E3 2666895118                       mov [es:ecx+24],dx                 ;到TSS中
   731                                  
   732 000002E8 26668B5610                       mov dx,[es:esi+0x10]               ;登记任务的LDT选择子
   733 000002ED 2666895160                       mov [es:ecx+96],dx                 ;到TSS中
   734                                  
   735 000002F2 26C7416400006700                 mov dword [es:ecx+100],0x00670000  ;T=0,I/O位串基地址为103
   736                                  
   737                                           ;在GDT中登记TSS描述符
   738 000002FA 268B4614                         mov eax,[es:esi+0x14]              ;TSS的起始线性地址
   739 000002FE 260FB75E12                       movzx ebx,word [es:esi+0x12]       ;段长度（界限）
   740 00000303 B900890000                       mov ecx,0x00008900                 ;TSS描述符，特权级0
   741 00000308 9A[B3010000]2800                 call sys_routine_seg_sel:make_seg_descriptor
   742 0000030F 9A[57010000]2800                 call sys_routine_seg_sel:set_up_gdt_descriptor
   743 00000316 2666894E18                       mov [es:esi+0x18],cx               ;登记TSS选择子到TCB
   744                                  
   745 0000031B 07                               pop es                             ;恢复到调用此过程前的es段 
   746 0000031C 1F                               pop ds                             ;恢复到调用此过程前的ds段
   747                                        
   748 0000031D 61                               popad
   749                                        
   750 0000031E C20800                           ret 8                              ;丢弃调用本过程前压入的参数 
   751                                        
   752                                  ;-------------------------------------------------------------------------------
   753                                  append_to_tcb_link:                         ;在TCB链上追加任务控制块
   754                                                                              ;输入：ECX=TCB线性基地址
   755 00000321 50                               push eax
   756 00000322 52                               push edx
   757 00000323 1E                               push ds
   758 00000324 06                               push es
   759                                           
   760 00000325 B830000000                       mov eax,core_data_seg_sel          ;令DS指向内核数据段 
   761 0000032A 8ED8                             mov ds,eax
   762 0000032C B808000000                       mov eax,mem_0_4_gb_seg_sel         ;令ES指向0..4GB段
   763 00000331 8EC0                             mov es,eax
   764                                           
   765 00000333 26C70100000000                   mov dword [es: ecx+0x00],0         ;当前TCB指针域清零，以指示这是最
   766                                                                              ;后一个TCB
   767                                                                               
   768 0000033A A1[7D0D0000]                     mov eax,[tcb_chain]                ;TCB表头指针
   769 0000033F 09C0                             or eax,eax                         ;链表为空？
   770 00000341 740E                             jz .notcb 
   771                                           
   772                                    .searc:
   773 00000343 89C2                             mov edx,eax
   774 00000345 268B02                           mov eax,[es: edx+0x00]
   775 00000348 09C0                             or eax,eax               
   776 0000034A 75F7                             jnz .searc
   777                                           
   778 0000034C 26890A                           mov [es: edx+0x00],ecx
   779 0000034F EB06                             jmp .retpc
   780                                           
   781                                    .notcb:       
   782 00000351 890D[7D0D0000]                   mov [tcb_chain],ecx                ;若为空表，直接令表头指针指向TCB
   783                                           
   784                                    .retpc:
   785 00000357 07                               pop es
   786 00000358 1F                               pop ds
   787 00000359 5A                               pop edx
   788 0000035A 58                               pop eax
   789                                           
   790 0000035B C3                               ret
   791                                           
   792                                  ;-------------------------------------------------------------------------------
   793                                  start:
   794 0000035C B930000000                       mov ecx,core_data_seg_sel          ;使ds指向核心数据段 
   795 00000361 8ED9                             mov ds,ecx
   796 00000363 8EC1                             mov es, ecx                        ;在有些虚拟机里未初始化的ES为随机值
   797 00000365 BB[22040000]                     mov ebx,message_1                    
   798 0000036A 9A[00000000]2800                 call sys_routine_seg_sel:put_string
   799                                                                           
   800                                           ;显示处理器品牌信息 
   801 00000371 B802000080                       mov eax,0x80000002
   802 00000376 0FA2                             cpuid
   803 00000378 A3[440D0000]                     mov [cpu_brand + 0x00],eax
   804 0000037D 891D[480D0000]                   mov [cpu_brand + 0x04],ebx
   805 00000383 890D[4C0D0000]                   mov [cpu_brand + 0x08],ecx
   806 00000389 8915[500D0000]                   mov [cpu_brand + 0x0c],edx
   807                                        
   808 0000038F B803000080                       mov eax,0x80000003
   809 00000394 0FA2                             cpuid
   810 00000396 A3[540D0000]                     mov [cpu_brand + 0x10],eax
   811 0000039B 891D[580D0000]                   mov [cpu_brand + 0x14],ebx
   812 000003A1 890D[5C0D0000]                   mov [cpu_brand + 0x18],ecx
   813 000003A7 8915[600D0000]                   mov [cpu_brand + 0x1c],edx
   814                                  
   815 000003AD B804000080                       mov eax,0x80000004
   816 000003B2 0FA2                             cpuid
   817 000003B4 A3[640D0000]                     mov [cpu_brand + 0x20],eax
   818 000003B9 891D[680D0000]                   mov [cpu_brand + 0x24],ebx
   819 000003BF 890D[6C0D0000]                   mov [cpu_brand + 0x28],ecx
   820 000003C5 8915[700D0000]                   mov [cpu_brand + 0x2c],edx
   821                                  
   822 000003CB BB[3F0D0000]                     mov ebx,cpu_brnd0                  ;显示处理器品牌信息 
   823 000003D0 9A[00000000]2800                 call sys_routine_seg_sel:put_string
   824 000003D7 BB[440D0000]                     mov ebx,cpu_brand
   825 000003DC 9A[00000000]2800                 call sys_routine_seg_sel:put_string
   826 000003E3 BB[780D0000]                     mov ebx,cpu_brnd1
   827 000003E8 9A[00000000]2800                 call sys_routine_seg_sel:put_string
   828                                  
   829                                           ;以下开始安装为整个系统服务的调用门。特权级之间的控制转移必须使用门
   830 000003EF BF[0A000000]                     mov edi,salt                       ;C-SALT表的起始位置
   831 000003F4 B904000000                       mov ecx,salt_items                 ;C-SALT表的条目数量
   832                                    .b3:
   833 000003F9 51                               push ecx
   834 000003FA 8B8700010000                     mov eax,[edi+256]                  ;该条目入口点的32位偏移地址
   835 00000400 668B9F04010000                   mov bx,[edi+260]                   ;该条目入口点的段选择子
   836 00000407 66B900EC                         mov cx,1_11_0_1100_000_00000B      ;特权级3的调用门(3以上的特权级才
   837                                                                              ;允许访问)，0个参数(因为用寄存器
   838                                                                              ;传递参数，而没有用栈)
   839 0000040B 9A[CE010000]2800                 call sys_routine_seg_sel:make_gate_descriptor
   840 00000412 9A[57010000]2800                 call sys_routine_seg_sel:set_up_gdt_descriptor
   841 00000419 66898F04010000                   mov [edi+260],cx                   ;将返回的门描述符选择子回填
   842 00000420 81C706010000                     add edi,salt_item_len              ;指向下一个C-SALT条目
   843 00000426 59                               pop ecx
   844 00000427 E2D0                             loop .b3
   845                                  
   846                                           ;对门进行测试
   847 00000429 BB[B2040000]                     mov ebx,message_2
   848 0000042E FF1D[0A010000]                   call far [salt_1+256]              ;通过门显示信息(偏移量将被忽略)
   849                                  
   850 00000434 BB[D5040000]                     mov ebx,message_3
   851 00000439 9A[00000000]2800                 call sys_routine_seg_sel:put_string ;在内核中调用例程不需要通过门
   852                                  
   853                                           ;创建任务控制块。这不是处理器的要求，而是我们自己为了方便而设立的
   854 00000440 B946000000                       mov ecx,0x46
   855 00000445 9A[27010000]2800                 call sys_routine_seg_sel:allocate_memory
   856 0000044C E8D0FEFFFF                       call append_to_tcb_link            ;将任务控制块追加到TCB链表 
   857                                        
   858 00000451 6A32                             push dword 50                      ;用户程序位于逻辑50扇区
   859 00000453 51                               push ecx                           ;压入任务控制块起始线性地址 
   860                                         
   861 00000454 E8EBFBFFFF                       call load_relocate_program
   862                                        
   863 00000459 BB[F1040000]                     mov ebx,do_status
   864 0000045E 9A[00000000]2800                 call sys_routine_seg_sel:put_string
   865                                        
   866 00000465 B808000000                       mov eax,mem_0_4_gb_seg_sel
   867 0000046A 8ED8                             mov ds,eax
   868                                        
   869 0000046C 0F005918                         ltr [ecx+0x18]                     ;加载任务状态段
   870 00000470 0F005110                         lldt [ecx+0x10]                    ;加载LDT
   871                                        
   872 00000474 8E5944                           mov ds,[ecx+0x44]                  ;切换到用户程序头部段
   873                                  
   874                                           ;以下假装是从调用门返回。摹仿处理器压入返回参数
   875 00000477 FF351C000000                     push dword [0x1c]                  ;调用前的堆栈段选择子
   876 0000047D 6A00                             push dword 0                       ;调用前的esp
   877                                  
   878 0000047F FF350C000000                     push dword [0x0c]                  ;调用前的代码段选择子
   879 00000485 FF3508000000                     push dword [0x08]                  ;调用前的eip
   880                                  
   881 0000048B CB                               retf
   882                                  
   883                                  return_point:                               ;用户程序返回点
   884 0000048C B830000000                       mov eax,core_data_seg_sel          ;因为用户程序是以JMP的方式使用调
   885 00000491 8ED8                             mov ds,eax                         ;用门@TerminateProgram，回到这
   886                                                                              ;里时，特权级为3，会导致异常。
   887 00000493 BB[F9040000]                     mov ebx,message_6
   888 00000498 9A[00000000]2800                 call sys_routine_seg_sel:put_string
   889                                  
   890 0000049F F4                               hlt
   891                                  
   892                                  core_code_end:
   893                                  
   894                                  ;-------------------------------------------------------------------------------
   895                                  SECTION core_trail
   896                                  ;-------------------------------------------------------------------------------
   897                                  core_end:
